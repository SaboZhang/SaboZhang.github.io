<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>InfoBar 悬浮于整个页面顶层</title>
      <link href="/post/8453/"/>
      <url>/post/8453/</url>
      
        <content type="html"><![CDATA[<h2 id="❓目标"><a href="#❓目标" class="headerlink" title="❓目标"></a>❓目标</h2><p>在 WinUI3 中 InfoBar 悬浮于整个页面顶层，无论滚动与否都不动；解决<code>Canvas.ZIndex</code>设置无效的问题。</p><hr><h2 id="✅-推荐方案：使用-Grid-实现浮动布局"><a href="#✅-推荐方案：使用-Grid-实现浮动布局" class="headerlink" title="✅ 推荐方案：使用 Grid 实现浮动布局"></a>✅ 推荐方案：使用 <code>Grid</code> 实现浮动布局</h2><p>用 <code>Grid</code> 做顶层容器</p><h3 id="🔧-方案如下"><a href="#🔧-方案如下" class="headerlink" title="🔧 方案如下"></a>🔧 方案如下</h3><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Page</span>    <span class="token attr-name">...</span>    <span class="token attr-name">Loaded</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>OnLoaded<span class="token punctuation">"</span></span>    <span class="token attr-name">Unloaded</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>OnUnloaded<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Grid</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 顶层 InfoBar --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>InfoBar</span> <span class="token attr-name"><span class="token namespace">x:</span>Name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>NoticeInfoBar<span class="token punctuation">"</span></span>                 <span class="token attr-name">MaxWidth</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>480<span class="token punctuation">"</span></span>                 <span class="token attr-name">Canvas.ZIndex</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>999<span class="token punctuation">"</span></span>                 <span class="token attr-name">Margin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span>                 <span class="token attr-name">HorizontalAlignment</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Center<span class="token punctuation">"</span></span>                 <span class="token attr-name">VerticalAlignment</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Top<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">i:</span>Interaction.Behaviors</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">behaviors:</span>StackedNotificationsBehavior</span> <span class="token attr-name"><span class="token namespace">x:</span>Name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>NotificationQueue<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">i:</span>Interaction.Behaviors</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>InfoBar</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 内容区域 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ScrollView</span> <span class="token attr-name">Margin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span>                    <span class="token attr-name">VerticalScrollBarVisibility</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Hidden<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>StackPanel</span> <span class="token attr-name"><span class="token namespace">x:</span>Name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ContentArea<span class="token punctuation">"</span></span> <span class="token attr-name">Margin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                <span class="token comment">&lt;!-- 这里保留原来的控件层级（SettingsPageControl 等） --&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>StackPanel</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ScrollView</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Grid</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Page</span><span class="token punctuation">&gt;</span></span></code></pre><hr><h2 id="📝-补充说明"><a href="#📝-补充说明" class="headerlink" title="📝 补充说明"></a>📝 补充说明</h2><ol><li><code>Grid</code> 是一种绝佳的布局容器，可以让你“叠放”多个控件（如 InfoBar + 页面内容）。</li><li><code>InfoBar</code> 设置 <code>VerticalAlignment="Top"</code> 就能固定在页面顶部，而不是随着内容一起滚动。</li><li>不再需要给 <code>InfoBar</code> 设置 <code>Canvas.ZIndex</code>，因为 Grid 默认后添加的元素会覆盖前面的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> .NET </tag>
            
            <tag> WinUI3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决dify 不支持.doc文件的问题</title>
      <link href="/post/14998/"/>
      <url>/post/14998/</url>
      
        <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Dify 作为一个开源的 LLM 应用开发平台，其内置的文档提取器在处理某些文件格式时存在局限性。根据 Dify 的官方文档和用户实践，默认的 Dify 解析方案对 <code>.doc</code>(Word 2003 格式) 文件的支持不够完善。使用时可能会出现 <code>UNSTRUCTURED_API_URL and UNSTRUCTURED_API_KEY must be set</code> 的问题。本文将介绍如何通过私有化部署 Unstructured API 来解决这一问题。</p><h2 id="解决方案概述"><a href="#解决方案概述" class="headerlink" title="解决方案概述"></a>解决方案概述</h2><p>Unstructured.io 提供了一个强大的文档解析 API，支持多种文件格式，包括 <code>.doc</code>、<code>.docx</code>、<code>.pdf</code> 等。通过本地部署 Unstructured API 服务，并将其集成到 Dify 中，可以完美解决 Dify 原生不支持 <code>.doc</code> 文件的问题。</p><h2 id="详细部署步骤（两种方式）"><a href="#详细部署步骤（两种方式）" class="headerlink" title="详细部署步骤（两种方式）"></a>详细部署步骤（两种方式）</h2><h3 id="1-自定义部署方式"><a href="#1-自定义部署方式" class="headerlink" title="1. 自定义部署方式"></a>1. 自定义部署方式</h3><h4 id="1-1-拉取-Unstructured-API-镜像"><a href="#1-1-拉取-Unstructured-API-镜像" class="headerlink" title="1.1 拉取 Unstructured API 镜像"></a>1.1 拉取 Unstructured API 镜像</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull downloads.unstructured.io/unstructured-io/unstructured-api:latest</code></pre><h4 id="1-2-运行-Unstructured-API-容器"><a href="#1-2-运行-Unstructured-API-容器" class="headerlink" title="1.2 运行 Unstructured API 容器"></a>1.2 运行 Unstructured API 容器</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">--env</span> <span class="token assign-left variable">HF_ENDPOINT</span><span class="token operator">=</span>https://hf-mirror.com <span class="token punctuation">\</span>     <span class="token parameter variable">--user</span> root <span class="token punctuation">\</span>     <span class="token parameter variable">-p</span> <span class="token number">8000</span>:8000 <span class="token punctuation">\</span>     <span class="token parameter variable">-d</span> <span class="token parameter variable">--rm</span> <span class="token punctuation">\</span>     <span class="token parameter variable">--name</span> unstructured-api <span class="token punctuation">\</span>     downloads.unstructured.io/unstructured-io/unstructured-api:latest</code></pre><p><strong>参数说明：</strong></p><ul><li><code>HF_ENDPOINT</code>: 指定 Hugging Face 镜像站点，解决国内无法访问的问题</li><li><code>-p 8000:8000</code>: 将容器端口映射到主机端口</li><li><code>--rm</code>: 容器退出时自动删除</li><li><code>--name</code>: 指定容器名称</li></ul><h3 id="2-容器编排方式（推荐）"><a href="#2-容器编排方式（推荐）" class="headerlink" title="2. 容器编排方式（推荐）"></a>2. 容器编排方式（推荐）</h3><p><code>.env</code> 文件中直接增加如下参数即可</p><pre class="language-ini" data-language="ini"><code class="language-ini"><span class="token comment"># 启用 unstructured profile</span><span class="token key attr-name">COMPOSE_PROFILES</span><span class="token punctuation">=</span><span class="token value attr-value">unstructured</span></code></pre><h3 id="3-配置-Dify-使用-Unstructured-API"><a href="#3-配置-Dify-使用-Unstructured-API" class="headerlink" title="3. 配置 Dify 使用 Unstructured API"></a>3. 配置 Dify 使用 Unstructured API</h3><p>修改 Dify 的配置文件 (通常是 <code>.env</code> 文件)，修改以下配置：</p><pre class="language-ini" data-language="ini"><code class="language-ini"><span class="token comment"># ETL 类型，支持：`dify`、`Unstructured`ETL_TYPE=Unstructured</span><span class="token comment"># Unstructured API 地址和 API key 本地部署API key 可以随便填，并且必须填</span><span class="token key attr-name">UNSTRUCTURED_API_URL</span><span class="token punctuation">=</span><span class="token value attr-value">http://unstructured:8000/general/v0/general</span><span class="token key attr-name">UNSTRUCTURED_API_KEY</span><span class="token punctuation">=</span><span class="token key attr-name">SCARF_NO_ANALYTICS</span><span class="token punctuation">=</span><span class="token value attr-value">true</span></code></pre><h2 id="高级功能配置（适用于自定义部署）"><a href="#高级功能配置（适用于自定义部署）" class="headerlink" title="高级功能配置（适用于自定义部署）"></a>高级功能配置（适用于自定义部署）</h2><p>如果使用容器编排方式下方的内容可以直接忽略。</p><p>Unstructured API 支持多种解析策略和高级功能：</p><ol><li><p><strong>大模型加持解析</strong>：通过设置 <code>hi_res</code> 参数为 <code>true</code>，可以启用大模型来增强 PDF 解析效果，但会增加响应时间。</p></li><li><p><strong>请求体示例</strong>：</p></li></ol><p><strong>设置 <code>body</code></strong></p><p><img src="https://obsidian-api.oss-cn-beijing.aliyuncs.com/ByteDiary/202504/28/Pasted%20image%2020250428095535.png?qTg7lXIArI" alt="Pasted image 20250428095535.png"></p><p><strong>设置 <code>header</code></strong></p><p><img src="https://obsidian-api.oss-cn-beijing.aliyuncs.com/ByteDiary/202504/28/Pasted%20image%2020250428095610.png?Z0vY4STRnw" alt="Pasted image 20250428095610.png"></p><ol><li><strong>支持的解析策略</strong>：</li><li><code>fast</code>: 快速解析模式</li><li><code>hi_res</code>: 高精度解析模式 (使用大模型)</li><li><code>ocr_only</code>: 仅使用 OCR 技术</li></ol><p>详细参数参考：<a href="https://github.com/Unstructured-IO/unstructured-api?tab=readme-ov-file#parameters">Unstructured-IO官方文档</a></p><h2 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h2><p>Unstructured API 使用了多种开源库和技术来处理不同格式的文档：</p><ul><li>对于 <code>.doc</code> 文件：使用 Apache POI 等库进行解析</li><li>对于 <code>.docx</code> 文件：利用 Python 的 <code>python-docx</code> 模块处理</li><li>对于 PDF 文件：支持常规解析和大模型增强解析两种模式</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><strong>性能考虑</strong>：启用 <code>hi_res</code> 模式会显著增加 API 响应时间，并且仅支持 PDF，建议仅在需要高精度解析时使用。</li><li><strong>模型下载</strong>：首次调用 API 时会从 Hugging Face 下载所需模型，使用国内镜像可以加速这一过程。</li><li><strong>私有化部署优势</strong>：本地部署可以确保数据不离开内网，满足金融、医疗等行业的合规要求。</li><li><strong>格式支持</strong>：Unstructured API 不仅支持 <code>.doc</code>，还支持 <code>.docx</code>、<code>.pdf</code>、<code>.pptx</code> 等多种格式。</li><li><strong>自定义容器编排：</strong> 创建<code>docker-compose.override.yaml​​</code>文件用于修改和扩展现有配置。当您运行 ​​​​<code>docker-compose up​​​​</code> 时，Docker Compose 会自动合并 <code>​​​​docker-compose.yaml</code>​​​​ 和 ​​​​<code>docker-compose.override.yaml</code>​​<a href="[Merge | Docker Docs](https://docs.docker.com/compose/how-tos/multiple-compose-files/merge/">参考资料</a>)</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过私有化部署 Unstructured API 并将其集成到 Dify 中，可以有效解决 Dify 原生不支持 <code>.doc</code> 文件的问题。这种方法不仅扩展了 Dify 的文件格式支持范围，还通过本地部署保障了数据安全，是企业构建知识库和智能问答系统的理想选择。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
          <category> 技术教程 </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> dify </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinUI3 绑定异常问题分析</title>
      <link href="/post/58950/"/>
      <url>/post/58950/</url>
      
        <content type="html"><![CDATA[<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a><strong>问题分析</strong></h3><h4 id="1-绑定失败的可能性"><a href="#1-绑定失败的可能性" class="headerlink" title="1. 绑定失败的可能性"></a>1. <strong>绑定失败的可能性</strong></h4><p>绑定 <code>BreadcrumbBar</code> 的 <code>ItemsSource="{Binding Breadcrumbs}"</code> 时发生了异常，表明以下可能性：</p><ul><li><strong><code>BreadcrumbBar</code> 的 <code>DataContext</code> 并非设置的 <code>ViewModel</code>。</strong></li><li>代码中你通过 <code>behaviors:NavigationViewHeaderBehavior.HeaderContext="{x:Bind ViewModel}"</code> 绑定了整个 ViewModel，但 <code>BreadcrumbBar</code> 的 <code>DataContext</code> 可能发生了覆盖。</li><li>在 <code>BreadcrumbBar</code> 中是否正确继承 <code>HeaderContext</code> 作为 <code>DataContext</code> 需要进一步验证。</li></ul><h4 id="2-使用-x-Bind-和-Binding-混用"><a href="#2-使用-x-Bind-和-Binding-混用" class="headerlink" title="2. 使用 x:Bind 和 Binding 混用"></a>2. <strong>使用 <code>x:Bind</code> 和 <code>Binding</code> 混用</strong></h4><ul><li>在 <code>BreadcrumbBar</code> 中使用了 <code>{Binding Breadcrumbs}</code>，而 <code>HeaderContext</code> 的设置使用了 <code>{x:Bind}</code>。这两种绑定方式在 WinUI 中有不同的工作原理：</li><li><code>{Binding}</code>：运行时解析路径。</li><li><code>{x:Bind}</code>：编译时绑定，性能更优。</li><li>如果 <code>BreadcrumbBar</code> 的 <code>DataContext</code> 未被正确继承，<code>{Binding}</code> 无法解析路径，导致异常。</li></ul><h4 id="3-资源字典中的-DataTemplate-使用-Binding"><a href="#3-资源字典中的-DataTemplate-使用-Binding" class="headerlink" title="3. 资源字典中的 DataTemplate 使用 Binding"></a>3. <strong>资源字典中的 DataTemplate 使用 Binding</strong></h4><p><code>BreadcrumbBar</code> 的定义在 <code>DataTemplate</code> 中，而 DataTemplate 本身可能没有自动继承 <code>HeaderContext</code>。需要显式设置 <code>DataContext</code>。</p><hr><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h3><h4 id="方案-1：明确设置-DataContext"><a href="#方案-1：明确设置-DataContext" class="headerlink" title="方案 1：明确设置 DataContext"></a>方案 1：明确设置 <code>DataContext</code></h4><p>确保 <code>BreadcrumbBar</code> 的 <code>DataContext</code> 被正确设置到 ViewModel。可以在 <code>BreadcrumbBar</code> 的定义中添加以下代码：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BreadcrumbBar</span>    <span class="token attr-name"><span class="token namespace">x:</span>Name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BreadcrumbBar<span class="token punctuation">"</span></span>    <span class="token attr-name">DataContext</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{Binding HeaderContext, RelativeSource={RelativeSource Mode=TemplatedParent}}<span class="token punctuation">"</span></span>    <span class="token attr-name">ItemsSource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{Binding Breadcrumbs}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span></code></pre><p>或者在 XAML 文件中调整 <code>HeaderContext</code> 的绑定方式：</p><pre class="language-markup" data-language="markup"><code class="language-markup">behaviors:NavigationViewHeaderBehavior.HeaderContext="{Binding}"</code></pre><h4 id="方案-2：改用-x-Bind"><a href="#方案-2：改用-x-Bind" class="headerlink" title="方案 2：改用 x:Bind"></a>方案 2：改用 <code>x:Bind</code></h4><p>用 <code>{x:Bind}</code> 替换 <code>Binding</code>，确保编译时绑定 ViewModel：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BreadcrumbBar</span>    <span class="token attr-name"><span class="token namespace">x:</span>Name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BreadcrumbBar<span class="token punctuation">"</span></span>    <span class="token attr-name">ItemsSource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{x:Bind Breadcrumbs, Mode=OneWay}<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span></code></pre><p>优点：</p><ul><li>提升性能，减少运行时错误。 注意：如果使用 <code>{x:Bind}</code>，确保 <code>BreadcrumbBar</code> 的 <code>DataContext</code> 在 XAML 中继承了正确的上下文。</li></ul><h4 id="方案-3：调试绑定上下文"><a href="#方案-3：调试绑定上下文" class="headerlink" title="方案 3：调试绑定上下文"></a>方案 3：调试绑定上下文</h4><p>在调试时检查 <code>BreadcrumbBar</code> 的实际 <code>DataContext</code>：</p><ul><li>在 C# 后台代码中添加 <code>BreadcrumbBar.DataContext</code> 的调试输出：</li></ul><pre class="language-csharp" data-language="csharp"><code class="language-csharp">Debug<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"BreadcrumbBar DataContext: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">BreadcrumbBar<span class="token punctuation">.</span>DataContext</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="方案-4：提供默认值"><a href="#方案-4：提供默认值" class="headerlink" title="方案 4：提供默认值"></a>方案 4：提供默认值</h4><p>如果 <code>Breadcrumbs</code> 在初始化时可能是 <code>null</code>，可以提供一个默认值，避免绑定异常：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BreadcrumbBar</span>    <span class="token attr-name"><span class="token namespace">x:</span>Name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BreadcrumbBar<span class="token punctuation">"</span></span>    <span class="token attr-name">ItemsSource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{Binding Breadcrumbs, FallbackValue={x:Null}}<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span></code></pre><hr><h3 id="最终推荐实现"><a href="#最终推荐实现" class="headerlink" title="最终推荐实现"></a><strong>最终推荐实现</strong></h3><p>综合以上建议，你可以调整为以下代码：</p><ol><li>在 XAML 中强制设置 <code>DataContext</code>：</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BreadcrumbBar</span>    <span class="token attr-name"><span class="token namespace">x:</span>Name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BreadcrumbBar<span class="token punctuation">"</span></span>    <span class="token attr-name">DataContext</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{Binding}<span class="token punctuation">"</span></span>    <span class="token attr-name">ItemsSource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{Binding Breadcrumbs}<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span></code></pre><ol><li>如果使用 <code>x:Bind</code>：</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BreadcrumbBar</span>    <span class="token attr-name"><span class="token namespace">x:</span>Name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BreadcrumbBar<span class="token punctuation">"</span></span>    <span class="token attr-name">ItemsSource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{x:Bind Breadcrumbs, Mode=OneWay}<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span></code></pre><hr><h3 id="调试建议"><a href="#调试建议" class="headerlink" title="调试建议"></a><strong>调试建议</strong></h3><ol><li>检查 <code>HeaderContext</code> 的实际值：<ul><li>确保 <code>ViewModel</code> 中的 <code>Breadcrumbs</code> 被正确设置。</li></ul></li><li>使用断点验证绑定路径：<ul><li>打印 <code>BreadcrumbBar</code> 的 <code>DataContext</code> 以确认其继承了正确的 <code>ViewModel</code>。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> .NET </tag>
            
            <tag> WinRT </tag>
            
            <tag> WinUI3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目升级依赖提示版本冲突错误</title>
      <link href="/post/41167/"/>
      <url>/post/41167/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>从 .NET 5 开始，CoreCLR 不再支持直接使用 WinMD 文件，导致依赖升级失败。需通过第三方组件实现 WinRT 功能。</p><pre class="language-C#" data-language="C#"><code class="language-C#">发现无法解析的“WinRT.Runtime”的不同版本之间存在冲突。 “WinRT.Runtime, Version=2.1.0.0, Culture=neutral, PublicKeyToken=99ea127f02d97709”与“WinRT.Runtime, Version=2.2.0.0, Culture=neutral, PublicKeyToken=99ea127f02d97709”之间存在冲突。 已选择“WinRT.Runtime, Version=2.1.0.0, Culture=neutral, PublicKeyToken=99ea127f02d97709”，因为它是主版本而“WinRT.Runtime, Version=2.2.0.0, Culture=neutral, PublicKeyToken=99ea127f02d97709”不是。 依赖于“WinRT.Runtime, Version=2.1.0.0, Culture=neutral, PublicKeyToken=99ea127f02d97709”</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>​<strong>安装 <code>Microsoft.Windows.CsWinRT</code> 包</strong>​<br>该包可自动生成 C# 投影代码，替代传统 WinMD 文件的直接引用方式，兼容 .NET 5+ 框架。</p><pre class="language-bash" data-language="bash"><code class="language-bash">Install-Package Microsoft.Windows.CsWinRT</code></pre><h2 id="关键说明"><a href="#关键说明" class="headerlink" title="关键说明"></a>关键说明</h2><ol><li><p>​<strong>兼容性优化</strong>​</p><ul><li>该方案适用于 .NET 5 及以上版本，解决 CoreCLR 对 WinMD 的原生支持限制。</li><li>通过 NuGet 包管理器安装后，项目会自动生成必要的 C# 绑定代码，无需手动处理 WinMD 文件。</li></ul></li><li><p>​<strong>依赖管理建议</strong>​</p><ul><li>在 <code>Directory.Packages.props</code> 中统一管理 NuGet 包版本，避免多项目版本冲突（参考）。</li><li>示例配置：</li></ul></li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PropertyGroup</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MicrosoftWindowsCsWinRTVersion</span><span class="token punctuation">&gt;</span></span>2.2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MicrosoftWindowsCsWinRTVersion</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>PropertyGroup</span><span class="token punctuation">&gt;</span></span></code></pre><ol><li><p>​<strong>跨平台兼容性</strong>​</p><ul><li>若需同时支持 Windows 和 Linux，可结合 GTK 封装层（如 <code>GTKSystem.Windows.Forms</code>）实现界面兼容。</li></ul></li></ol><h2 id="验证步骤"><a href="#验证步骤" class="headerlink" title="验证步骤"></a>验证步骤</h2><ol><li>安装包后重新编译项目，确保无 WinMD 相关编译错误。</li><li>运行时检查是否依赖 <code>Microsoft.Windows.CsWinRT.Runtime.dll</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> .NET </tag>
            
            <tag> WinRT </tag>
            
            <tag> WinUI3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置PDFjs报错无法显示</title>
      <link href="/post/43125/"/>
      <url>/post/43125/</url>
      
        <content type="html"><![CDATA[<h2 id="一、错误描述"><a href="#一、错误描述" class="headerlink" title="一、错误描述"></a>一、错误描述</h2><p>在使用 PDFjs 时，可能会遇到以下错误：<code>Failed to load module script: Expected a JavaScript module script but the server responded...</code>。</p><p>错误原因是服务器返回的文件 MIME 类型不正确。浏览器期望模块脚本的 MIME 类型为 <code>application/javascript</code>，但实际服务器返回的不是这个类型，导致浏览器拒绝加载并显示此错误。</p><h2 id="二、解决办法"><a href="#二、解决办法" class="headerlink" title="二、解决办法"></a>二、解决办法</h2><p>以下记录了解决过程，以及本人最终的解决办法。</p><h3 id="（一）Nginx-配置"><a href="#（一）Nginx-配置" class="headerlink" title="（一）Nginx 配置"></a>（一）Nginx 配置</h3><ol><li><p><strong>尝试一（未生效）</strong></p><ul><li>在 Nginx 的默认 <code>mime.types</code> 文件中没有为 <code>.mjs</code> 扩展名设置条目，这意味着它将被作为 <code>application/octet-stream</code> 而不是 <code>application/javascript</code> 进行服务。</li><li>网上查询到的解决方法有的是在 <code>http</code> 模块直接添加以下内容，或者直接修改 <code>mime.types</code>：</li></ul><pre class="language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">include</span> mime.types</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">types</span></span> <span class="token punctuation">{</span>        <span class="token directive"><span class="token keyword">application/javascript</span> mjs</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>但这种方式在某些情况下可能没有起到作用。</li></ul></li><li><p><strong>尝试二（部分生效）</strong></p><ul><li>另一种方式是在 <code>location</code> 中添加以下代码：</li></ul><pre class="language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">{</span>    <span class="token comment">#…</span>    <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>        <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>        <span class="token directive"><span class="token keyword">server_name</span> your_domain.com</span><span class="token punctuation">;</span>        <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>            <span class="token directive"><span class="token keyword">root</span> /path/to/files</span><span class="token punctuation">;</span>            <span class="token directive"><span class="token keyword">types</span></span> <span class="token punctuation">{</span>                <span class="token directive"><span class="token keyword">application/javascript</span> mjs</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">#…</span><span class="token punctuation">}</span></code></pre><ul><li>这种方式在火狐中正常显示，但在 Chromium 内核的浏览器中访问对应的路径变成了下载，不管什么样的路径，无论是登录还是正常的页面。</li></ul></li><li><p><strong>最终解决办法</strong></p><ul><li>在 <code>mime.types</code> 中修改，增加 <code>application/javascript mjs;</code>，并且在 <code>location</code> 中使用 <code>include</code> 指令引入 <code>mime.types</code>，此时问题解决。</li></ul><pre class="language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">{</span>    <span class="token comment">#…</span>    <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>        <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>        <span class="token directive"><span class="token keyword">server_name</span> your_domain.com</span><span class="token punctuation">;</span>        <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>            <span class="token directive"><span class="token keyword">root</span> /path/to/files</span><span class="token punctuation">;</span>            <span class="token directive"><span class="token keyword">include</span> /path/to/mime.types</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">#…</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="（二）其他方法"><a href="#（二）其他方法" class="headerlink" title="（二）其他方法"></a>（二）其他方法</h3><p>除了在 Nginx 中解决外，还有其他解决办法：</p><ol><li>降低版本使用非 <code>.mjs</code> 的版本。</li><li>修改 <code>.mjs</code> 后缀为 <code>.js</code>。</li></ol><p>对于 Apache 的配置，方法也类似，就是添加 <code>application/javascript mjs;</code>，关于apache的配置，方法也类似，就是添加<code>application/javascript mjs;</code>在<code>.htaccess</code>中或者在<code>server configuration</code>文件中添加`AddType application/javascript .mjs。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
          <category> 技术教程 </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> 解决方案 </tag>
            
            <tag> PDFjs </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快递隐私：一份不速之&quot;广告&quot;引发的思考</title>
      <link href="/post/5579/"/>
      <url>/post/5579/</url>
      
        <content type="html"><![CDATA[<h2 id="代发空包现象"><a href="#代发空包现象" class="headerlink" title="代发空包现象"></a>代发空包现象</h2><p>在电子商务的繁荣浪潮中，“618”购物节成为了一个商海争霸的战场。这个时候，不仅购物平台的营销活动热闹非凡，各个商家也开启了他们的销量竞赛。但伴随而来的销量造假问题亦不绝于耳。为了规避监管并创造“真实”发货的假象，一个灰色市场行业悄然诞生，即“代发空包”。这种令人匪夷所思的现象，背后展现的是一些商家对于销量真实性的无视，也是对消费者信任的背叛。</p><h2 id="个人经历"><a href="#个人经历" class="headerlink" title="个人经历"></a>个人经历</h2><p>回想起那个平凡的日子，当我疲惫地回到家中，看手机提示有一份来自武汉的快递时，我的内心充满了疑惑和期待。我并没有在记忆中留下任何购物的痕迹，也没有期待中的物品即将到来。这份突如其来的快递，像是一个未解之谜，吸引着我迫不及待的跑去快递柜把快递取了回来。然而，拿到手里的那一刻，发现包裹很轻，然而随着包裹的层层剥开，我的期待逐渐转化为失落。原本以为可能是远方朋友寄来的心意，或者是某个未曾预料到的惊喜，但当我看到包裹里空空如也的盒子里就两张广告宣传纸时，上面甚至还留了可能时诈骗的微信二维码以及抽奖信息。此时我的心中涌起了一股难以言喻的复杂情感。<br><img src="https://img.luckyits.com/2024/05/29/665741374c564.webp" alt="广告"><br>这份快递让我深刻感受到了隐私侵犯的冲击波。在这个数字化和信息化高速发展的时代，我们的个人信息似乎已经成为了某种“公共资源”，被各种企业随意获取、利用和交易。我们的姓名、地址、电话号码，甚至是我们的购物习惯、兴趣爱好，都被这些企业一一记录，用于他们的营销和广告推广。<br><img src="https://img.luckyits.com/2024/05/29/6657505978221.webp" alt="空包快递"></p><h2 id="隐私问题"><a href="#隐私问题" class="headerlink" title="隐私问题"></a>隐私问题</h2><p>如果你也经历过收到空包裹的情况，那就要警惕了，你的信息可能被泄露了。空包裹是刷单团伙利用被泄露的个人信息形成虚假物流信息产生的，收到空包意味着个人信息已经被泄露。我在这次收到空包之后，也在网上看到了很多类似的情况。根据网上的信息来看，部分消费者收到空包裹后会到网点查询来源，但这些快递面单上的寄件人信息一般为<strong>虚假信息</strong>， 配送网点无法查询，需要联系寄件网点的快递员。如果收到包裹确认自己没有网购或者近期没有未到快递的，你可以拒收，让快递员原路退回。其次，如果频繁收到空包裹，对你的生活已经造成了干扰，可以向淘宝、天猫等网站进行投诉。同时我们也要向邮寄网点投诉、国家邮政局投诉、如果可以查到相关邮寄的人员的公司（如果有的话）我门还可以向当地各监管部门投诉。<br>事实上针对这些情况，这已经不是什么比较罕见的问题。早在2021年的时候国家市场监督管理总局官网公布了第二批网络虚假宣传不正当竞争典型案例，涉及四种不同类型的刷单方式，其中就包括“寄空包”刷单行为。市场监管总局表示，不法分子通过“物流”造假完成交易的全过程，具有很强的隐蔽性，是下一阶段监管部门重点打击的违法行为。<br><img src="https://img.luckyits.com/2024/05/29/66574360435c4.webp" alt="案例"><br>“空包裹刷单屡禁不止，是因为有一条完整的利益链，快递员、快递公司、商家、电商平台、空包网站都在攫取利益。”一名业内人士表示。</p><h2 id="思考与建议"><a href="#思考与建议" class="headerlink" title="思考与建议"></a>思考与建议</h2><p>作为普通人的我们不仅需要提高警惕对待每一个不明快递，更要学会保护自己的个人信息，不让电话、住址等敏感数据轻易外泄。</p><ol><li><strong>提高警惕</strong>：消费者在收到不明快递时，要提高警惕，不要轻易相信快递中的广告和信息。</li><li><strong>保护个人信息</strong>：要时刻注意个人信息的保护，不要随意透露姓名、地址、电话号码等敏感信息。</li><li><strong>提高法律意识</strong>：了解相关法律法规，遇到个人信息泄露等问题时，要及时采取措施，维护自己的合法权益。<br>通过这些措施，我们可以更好地保护自己的隐私，避免成为不法行为的受害者。同时，也要呼吁社会各界共同努力，营造一个安全、诚信的网络环境。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快递 </tag>
            
            <tag> 思考 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决yarn安装创建项目时报错，文件名、目录名或卷标语法不正确</title>
      <link href="/post/677/"/>
      <url>/post/677/</url>
      
        <content type="html"><![CDATA[<p>在开发过程中，我们可能会遇到 <code>npm</code> 和 <code>yarn</code> 的全局安装位置不一致的问题。从而导致一些命令无法正常使用。本文将分享我如何解决这个问题的经历，希望对遇到类似问题的开发者有所帮助。</p><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>先说分析一下我的情况，我用的是<code>npm</code>安装的<code>yarn</code></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i <span class="token parameter variable">-g</span> <span class="token function">yarn</span></code></pre><p>并且我重新设定了<code>npm</code>的全局安装位置和缓存位置<br>然后创建项目时，报了如下错误：<br><img src="https://img.luckyits.com/2024/05/24/665022b1b3e39.webp" alt="错误"><br>通过以下命令可以查看npm的全局安装位置和缓存位置</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> config get prefix <span class="token comment"># 输出 E:\Repository\npm\node_global</span><span class="token function">npm</span> config get cache  <span class="token comment"># 输出 E:\Repository\npm\node_cache</span></code></pre><h2 id="网上的解决方案"><a href="#网上的解决方案" class="headerlink" title="网上的解决方案"></a>网上的解决方案</h2><p>尝试了一种常见的解决方案，即查看 <code>yarn</code> 命令的目录并将其添加到环境变量 Path 中：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">yarn</span> global bin <span class="token comment"># 输出：E:\Repository\npm\node_global\bin</span></code></pre><p>然而这种方法在我这里并没有起到什么作用，还是存在的问题。那些文章都说问题解决了，可是却没有解决我的问题。<br>我们再仔细看一下这种解决方案，你会发现，他们的 npm 的全局安装位置是默认的 C 盘目录，而我修改了 npm 的全局安装位置。查看 yarn 的全局安装位置：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">yarn</span> global <span class="token function">dir</span></code></pre><p>输出下图的路径（打码的为用户名）：<br><img src="https://img.luckyits.com/2024/05/24/66503aed3d6cb.webp" alt="yarn安装位置"></p><h2 id="修改yarn-的全局安装位置"><a href="#修改yarn-的全局安装位置" class="headerlink" title="修改yarn 的全局安装位置"></a>修改yarn 的全局安装位置</h2><p><code>yarn</code> 的全局安装位置与 bin 的位置并不一致，所以要修改 yarn的全局安装位置试试，将其修改为与 npm 一致（顺便把缓存位置也改了）：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">yarn</span> config <span class="token builtin class-name">set</span> global-folder <span class="token string">"E:\Repository<span class="token entity" title="\n">\n</span>pm\global"</span><span class="token function">yarn</span> config <span class="token builtin class-name">set</span> cache-folder <span class="token string">"E:\Repository<span class="token entity" title="\n">\n</span>pm<span class="token entity" title="\c">\c</span>ache"</span></code></pre><div class="note info modern"><p><strong><span class="p red">注意</span></strong>：建议将 <code>yarn</code> 的全局文件夹放在另一个目录，以避免与 npm 的全局命令冲突。</p></div><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在修改了 yarn 的全局安装位置后重新执行了命令</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">yarn</span> create vite</code></pre><p><img src="https://img.luckyits.com/2024/05/24/66505003a4804.webp" alt="重新执行命令"></p><p>上图已经正常执行命令了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述步骤，我解决了 <code>npm</code> 安装 <code>yarn</code> 后全局安装位置不一致从而导致<code>yarn</code>命令执行出现问题。希望我的解决方法能够帮助到遇到类似问题的开发者。如果你有其他更好的解决方案，欢迎分享交流。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 开发 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> npm </tag>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下 Microsoft Edge 闪退的解决思路</title>
      <link href="/post/38659/"/>
      <url>/post/38659/</url>
      
        <content type="html"><![CDATA[<p>Edge浏览器作为微软旗下的新时代网络门户(现阶段Windows11、Windows10都会预装)，凭借其迅速且高效的性能赢得了广泛用户的青睐。然而，尽管大多数时候它工作得相当出色，但在某些特定情境下，用户可能会遭遇到浏览器意外闪退的尴尬局面。为此，本文旨在深入探讨一种解决Edge浏览器闪退困扰的有效方法，期望能在你面对同样问题时提供一丝启发。</p><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>近日，一位朋友向我求助，他的Edge浏览器突然间无法启动，遇到了白屏闪退的问题，并请求我协助解决。以下是我为解决该问题而采纳的思路和步骤，希望能对遇到同样问题的你有所帮助。</p><div style="text-align: center;"><video width="854" height="480" controls="">   <source src="https://wallpaper.luckyits.com//album/2024/20240521132703.mp4" type="video/mp4"> </video> </div><h2 id="网络解决方案"><a href="#网络解决方案" class="headerlink" title="网络解决方案"></a>网络解决方案</h2><p>做过简单的了解之后，先在网络上搜索了一下类似问题，发现有不少搜索结果，其中有两个搜索结果的问题相似，于是乎，我将解放方案发给了朋友。</p><ol><li>设置Windows的隐藏文件夹可见。</li><li>然后打开<code>C:\Users\用户名\AppData\Local\Microsoft\Edge\User Data\Default\</code> 然后删除目录下的<code>Nurturing</code>文件夹。<br>以为问题就这样简单的解决了，结果过了一会，朋友又联系我说，“还是打不开，闪退”。此时，我还不是很慌，接着对朋友进行指导。</li></ol><h2 id="进一步操作"><a href="#进一步操作" class="headerlink" title="进一步操作"></a>进一步操作</h2><ol><li>打开<code>C:\Users\用户名\AppData\Local\Microsoft\Edge\</code>目录（此目录是用户的各种配置文件的存放目录）</li><li>将目录下的<code>User Data</code>更改为<code>User Data.old</code>，然后重新打开Edge。<br>结果过了一会，朋友的微信又来了，说是不行，提示文件占用。然后网上的解决闪退的办法他也试了很多，但是都没有解决问题。</li></ol><h2 id="远程尝试"><a href="#远程尝试" class="headerlink" title="远程尝试"></a>远程尝试</h2><p>随即开始使用向日葵远程查看问题。</p><ol><li>尝试在对应的目录下进行重命名，发现提示在占用，但是在任务管理器中，没有发现任何跟Edge相关的进程，</li><li>下载<code>powerToys</code>工具，准备使用它的<code>File Locksmith</code>功能来查看一下哪个进程在占用<br><img src="https://img.luckyits.com/2024/05/21/664c372513e84.webp" alt="File Locksmith"><br>结果不知道什么原因，该工具没有在朋友电脑的右键菜单中出现，以为是没有生效，在任务管理器中，重启资源管理器，结果还是没有出现在右键菜单中。此时，汗流浃背了啊，兄弟！<br>再次尝试改名还是不行，于是就直接创建了一个<code>User Data.old</code>文件夹，然后再进入<code>User Data</code>全选，然后<kbd>Ctrl</kbd> + <kbd>X</kbd> 打开<code>User Dta.old</code>目录，然后<kbd>Ctrl</kbd> + <kbd>V</kbd>成功将所有文件都移动到了<code>User Data.old</code>目录下，然后再次尝试打开Edge, 尴尬的情况出现了，它又闪退了。</li></ol><h2 id="注册表修改"><a href="#注册表修改" class="headerlink" title="注册表修改"></a>注册表修改</h2><p>本着既然都远程了，那就要成功解决的原则，开始怀疑是不是朋友公司电脑硬件水平太次了，然后Edge默认是开着硬件加速的，随即我开始尝试修改注册表。</p><blockquote><blockquote><p>以下步骤适用于 Windows 系统中的 Microsoft Edge 77 及以上版本(现在应该没有几个人用100版本以下的Edge了吧)，会对所有用户账户生效。</p></blockquote></blockquote><ol><li>使用<kbd>Win</kbd> + <kbd>R</kbd>快捷键打开「运行」对话框，执行regedit打开注册表编辑器。</li><li><p>导航到以下路径（没有就新建）：</p><pre class="language-bash" data-language="bash"><code class="language-bash">HKEY_LOCAL_MACHINE<span class="token punctuation">\</span>SOFTWARE<span class="token punctuation">\</span>Policies<span class="token punctuation">\</span><span class="token punctuation">\</span>Microsoft<span class="token punctuation">\</span>Edge</code></pre></li><li><p>新建一个名为<code>HardwareAccelerationModeEnabled</code>的 DWORD (32-位) 值，将其十六进制值设置为：</p><ul><li><code>0</code>表示禁用图形加速</li><li><code>1</code>表示启用图形加速<br><img src="https://img.luckyits.com/2024/05/21/664c3be7894ef.webp" alt="注册表修改"></li></ul></li><li>重启计算机。然后朋友再次尝试打开Edge，结果还是闪退。又微信跟我说，还是不行。</li></ol><h2 id="覆盖安装Edge-卸载"><a href="#覆盖安装Edge-卸载" class="headerlink" title="覆盖安装Edge/卸载"></a>覆盖安装Edge/卸载</h2><p>接着我又指导朋友下载Bate版本的Edge,然后直接覆盖安装（因为Edge浏览器不支持常规卸载）。然而，这个方法也没有解决问题。</p><p>紧接着我又继续远程，尝试到安装目录<code>C:\Program Files (x86)\Microsoft\Edge\Application\125.0.2535.51\Installer</code>下，以管理员身份打开控制台，并输入以下命令进行卸载：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">.\setup.exe --uninstall --system-level --verbose-logging --force-uninstall</code></pre><p>然而，卸载操作并没有达到预期效果，卸载失败了。</p><h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><p>接着我又开始了尝试，使用Google Chrome打开Edge的官网安装页面，因为检测到当前电脑已安装Edge,所以没有显示下载按钮，显示的打开Edge的按钮。<br><img src="https://img.luckyits.com/2024/05/21/664c3f3251197.webp" alt="打开Edge的按钮"><br>点击再试一次之后，浏览器在尝试跳转一个网址。并且没有立即闪退，再等待了大概30秒左右的时间之后，Edge又闪退了。<br>紧接着又尝试了几次，在尝试的过程中，我注意到，我只要点击<strong>新建标签页</strong>会立马闪退（可能是巧合）沉思了一会，考虑是不是因为安装的扩展导致的，于是找到了Edge的扩展目录C:\Program Files (x86)\Microsoft\Edge\Application\版本号\目录下的Extensions文件夹，直接将其进行了删除，此时再次尝试打开，见证期间的时刻，Edge正常打开了，没有闪退！<br>因为登录了微软账号，所以所有的扩展都重新进行了同步，然后发现朋友装的扩展，就有一个跟标签页有关，但是重新设置之后，没有再次出现问题。<br><img src="https://img.luckyits.com/2024/05/21/664c43d4428c9.webp" alt="扩展"></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>目前朋友安装的就是这些扩展，目前问题没有再复现了。问题解决了，定位到是扩展问题，但是没有确定是哪个扩展，不然得把这个扩展的作者祭天了,兼容性做太差了，都出现恶性BUG了（手动狗头）。</p><h2 id="类似问题解决思路"><a href="#类似问题解决思路" class="headerlink" title="类似问题解决思路"></a>类似问题解决思路</h2><ol><li>备份用户配置文件，然后删除配置文件进行尝试；目录<code>C:\Users\用户名\AppData\Local\Microsoft\Edge\User Data</code></li><li>禁用硬件加速，参考<a href="#注册表修改">注册表修改</a></li><li>删除扩展文件夹Extensions，目录<code>C:\Program Files (x86)\Microsoft\Edge\Application\</code></li><li>临时解决方案，打开<code>C:\Program Files (x86)\Microsoft\Edge\Application\版本号</code>，运行<code>msedgewebview2.exe</code>可以临时使用。</li><li><p>通过系统设置进行修复。</p><ul><li><p>打开设置-》应用-》安装的应用找到Microsoft Edge;<br><img src="https://img.luckyits.com/2024/05/21/664c5195bf471.webp" alt="设置"></p></li><li><p>选择Microsoft Edge，点击三个点，然后点修改，在弹出的对话框点修复；<br><img src="https://img.luckyits.com/2024/05/21/664c51944eab3.webp" alt="修复"><br>这些是类似问题的一些解决方案，希望对你有所帮助。遇到类似的问题可以进行参考。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闪退 </tag>
            
            <tag> 解决思路 </tag>
            
            <tag> Windows </tag>
            
            <tag> Microsoft Edge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo分类的使用</title>
      <link href="/post/53142/"/>
      <url>/post/53142/</url>
      
        <content type="html"><![CDATA[<p>如果你熟悉官方文档，那这篇文章可能帮助不到你，但是如果你跟我一样是刚接触hexo，或者你只是想快速了解hexo的分类标签的话，那么这篇文章或许能帮到你。在很多情况下我们写文章的时候可能需要让一篇文章同属于多个分类标签，例如我写的<a href="/post/59018">关于prettier报错的解决方案</a>的文章，我即想让它属于<code>经验分享</code>的分类又想让它属于<code>技术教程</code>的分类，如果使用类似wordpress的分类标签的话，我们只需要在文章的front matter中按照如下的格式添加即可：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">categories</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token punctuation">[</span>经验分享<span class="token punctuation">]</span> <span class="token punctuation">-</span> <span class="token punctuation">[</span>技术教程<span class="token punctuation">]</span></code></pre><p>但是hexo的分类标签是按照<code>/categories/分类名/</code>的形式来创建的，所以如果按照上述的格式来添加的话，hexo会自动将<code>经验分享</code>这个分类名作为一级分类，而<code>技术教程</code>这个分类名作为二级分类，这样会导致我们如果创建过<code>技术教程</code>这个分类的话，会出现重复的分类名称。<br><img src="https://img.luckyits.com/2024/05/19/6649b2e731205.png" alt="分类名重复的情况"></p><p>按照官方的解释，categories 这个选项有两种配置方法（其实有三种）。那我们就来讲讲这三种配置方法。</p><h2 id="子分类"><a href="#子分类" class="headerlink" title="子分类"></a>子分类</h2><p>下面的分类会将该分章放到<code>经验分享/经验分享</code>这个分类下:</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">categories</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> 经验分享 <span class="token punctuation">-</span> 技术教程</code></pre><p>同样的作用我们也可以这样写。</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">categories</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>经验分享<span class="token punctuation">,</span> 技术教程<span class="token punctuation">]</span></code></pre><p>上面两种方法最终效果一样，都是将文章放在了一个子分类的目录下，就是上图中不符合我预期的情况。</p><h2 id="多个分类"><a href="#多个分类" class="headerlink" title="多个分类"></a>多个分类</h2><p>如果我们的要求是将文章同时分到多个不同的分类中呢，我们应该这样：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">categories</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token punctuation">[</span>经验分享<span class="token punctuation">]</span> <span class="token punctuation">-</span> <span class="token punctuation">[</span>技术教程<span class="token punctuation">]</span></code></pre><p>这样，就可以将上面的文章分类到<code>经验分享</code>和<code>技术教程</code>这两个不同的目录中了。扩展一下，如果我们需要将一篇Java文章分类到 <code>Java/Servlet</code> 和 <code>Programming</code> 两个不同的目录下，我们应该如下写：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">categories</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token punctuation">[</span>Java<span class="token punctuation">,</span> Servlet<span class="token punctuation">]</span> <span class="token punctuation">-</span> <span class="token punctuation">[</span>Programming<span class="token punctuation">]</span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hexo.io/zh-cn/docs/front-matter.html#%E5%88%86%E7%B1%BB">hexo 分类</a></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分类 </tag>
            
            <tag> 标签 </tag>
            
            <tag> hexo </tag>
            
            <tag> 经验教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delete`␍` eslint(prettier/prettier) 错误的解决方案</title>
      <link href="/post/59018/"/>
      <url>/post/59018/</url>
      
        <content type="html"><![CDATA[<h2 id="问题及原因"><a href="#问题及原因" class="headerlink" title="问题及原因"></a>问题及原因</h2><p>在 VSCode 编码过程中，遇到了 ESLint 提示的“Delete ␍ eslint(prettier/prettier)”错误。这通常是因为安装的 Prettier 插件预设了与您操作系统不一致的文件换行符。由于不同操作系统（如 Windows、Linux 和 macOS）具有各自的换行符格式，导致兼容性问题。<br><img src="https://img.luckyits.com/2024/05/19/66498f80a5184.png" alt="错误提示"><br><img src="https://img.luckyits.com/2024/05/19/6649865211c80.png" alt="prettier插件"></p><p>例如，Windows 使用 <code>\r\n</code>（CRLF）作为换行符，而 Linux 和 macOS 则采用 <code>\n</code>（LF）。在一些较早的 macOS 版本中，甚至使用 <code>\r</code>（CR）作为换行符。为了工程化的一致性，许多项目仓库默认规定使用 LF 作为换行符。但当 Prettier 插件默认设置为 LF，而开发环境为 Windows 时，就会出现提示删除 <code>\r</code> 的错误。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>打开设置，或者直接快捷键 <code>Ctrl + ,</code> 在搜索栏输入 <code>prettier</code>，然后找到 <code>End Of Line</code> 这个选项设置为 <code>auto</code><br><img src="https://img.luckyits.com/2024/05/19/66498a65ae8d9.png" alt="插件设置"></li><li>在 <code>.prettierrc</code> 文件中添加 <code>endOfLine: "auto"</code> 选项，或者在在<code>.eslintrc.cjs</code>中增加配置 如下：<br><strong>prettierrc</strong>文件配置</li></ol><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"endOfLine"</span><span class="token operator">:</span> <span class="token string">"auto"</span><span class="token punctuation">}</span></code></pre><p><strong>eslintrc.cjs</strong>文件配置</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token property">"rules"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token property">"prettier/prettier"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"error"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token property">"endOfLine"</span><span class="token operator">:</span> <span class="token string">"auto"</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><ol><li><p>点击一个个文件手动切换（效率较低）<br><img src="https://img.luckyits.com/2024/05/19/66498b9eb6976.png" alt="手动切换"></p></li><li><p>配置git （最优）<br><code>core.autocrlf</code> 是 Git 中一个重要的配置选项，它决定了 Git 如何处理换行符（newline）的转换。在跨平台协作的项目中，不同的操作系统（如 Windows、Linux、macOS）使用不同的换行符风格，这可能会导致不必要的麻烦。<br>core.autocrlf 配置有三个值：</p></li></ol><ul><li><code>true</code>：当检出代码时，将 LF 转换为 CRLF；当提交代码时，将 CRLF 转换为 LF。</li><li><code>input</code>：检出代码时不转换，提交代码时将 CRLF 转换为 LF。</li><li><code>false</code>：不进行任何转换<br>VScode 能够自动识别文件的换行符是LF还是CRLF。如果你用的是windows，文件编码是UTF-8且包含中文，最好全局将autocrlf设置为false, 在<code>CMD</code>或者<code>Windows Terminal</code>中输入<code>git config --global core.autocrlf false</code>这一命令的关键在于禁用了 Git 的自动换行符转换功能。</li></ul><p>设置此全局配置后，需要重新拉取仓库中的代码，以确保所有文件都按照预期处理换行符。这样做可以保证不同操作系统间的文件一致性，从而避免潜在的兼容性问题。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eslint </tag>
            
            <tag> vscode </tag>
            
            <tag> prettier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FRP与Nginx服务搭建</title>
      <link href="/post/59328/"/>
      <url>/post/59328/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>FRP（Fast Reverse Proxy）是一款高性能的反向代理服务器，可以帮助您轻松地将本地服务发布到公网。Nginx是一款高性能的HTTP服务器，可以用于反向代理、负载均衡、动静分离等场景。<br>本文将介绍如何在服务器上搭建FRP和Nginx服务，并通过FRP将本地服务发布到公网。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li>一台服务器，建议配置2核4GB内存以上</li><li>公网IP地址</li><li>域名（可选）</li></ul><h3 id="FRP安装"><a href="#FRP安装" class="headerlink" title="FRP安装"></a>FRP安装</h3><h4 id="下载FRP"><a href="#下载FRP" class="headerlink" title="下载FRP"></a>下载FRP</h4><p>FRP支持Windows、Linux、MacOS等多种操作系统，您可以根据您的操作系统下载对应版本的FRP。<br>下载地址： <a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><ol><li>解压下载的压缩包。</li><li>将 frpc 复制到内网服务所在的机器上。</li><li>将 frps 复制到拥有公网 IP 地址的机器上，并将它们放在任意目录。</li></ol><h4 id="配置FRP"><a href="#配置FRP" class="headerlink" title="配置FRP"></a>配置FRP</h4><p>FRP的配置文件为 frps.toml，默认位于 frp 目录下。</p><ol><li>配置frps.toml<br>在 frps.toml 文件中添加以下内容，以指定 HTTP 请求的监听端口为 8080：</li></ol><pre class="language-toml" data-language="toml"><code class="language-toml"><span class="token key property">bindPort</span> <span class="token punctuation">=</span> <span class="token number">7000</span><span class="token key property">vhostHTTPPort</span> <span class="token punctuation">=</span> <span class="token number">8080</span></code></pre><p>如果需要配置 HTTPS 代理，还需要设置 vhostHTTPSPort。</p><ol><li>配置frpc.toml<br>在 frpc.toml文件中添加以下内容，确保设置了正确的服务器 IP 地址、本地 Web 服务监听端口和自定义域名：</li></ol><pre class="language-toml" data-language="toml"><code class="language-toml"><span class="token key property">serverAddr</span> <span class="token punctuation">=</span> <span class="token string">"x.x.x.x"</span><span class="token key property">serverPort</span> <span class="token punctuation">=</span> <span class="token number">7000</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token table class-name">proxies</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token key property">name</span> <span class="token punctuation">=</span> <span class="token string">"web"</span><span class="token key property">type</span> <span class="token punctuation">=</span> <span class="token string">"http"</span><span class="token key property">localIP</span> <span class="token punctuation">=</span> <span class="token string">"127.0.0.1"</span>               <span class="token key property">localPort</span> <span class="token punctuation">=</span> <span class="token number">8081</span><span class="token key property">customDomains</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">"www.yourdomain.com"</span><span class="token punctuation">]</span>  <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token table class-name">proxies</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token key property">name</span> <span class="token punctuation">=</span> <span class="token string">"ssh"</span><span class="token key property">type</span> <span class="token punctuation">=</span> <span class="token string">"tcp"</span><span class="token key property">localIP</span> <span class="token punctuation">=</span> <span class="token string">"127.0.0.1"</span><span class="token key property">localPort</span> <span class="token punctuation">=</span> <span class="token number">22</span><span class="token key property">remotePort</span> <span class="token punctuation">=</span> <span class="token number">6000</span></code></pre><p>配置说明：</p><ul><li>bindPort: 服务端与客户端通信端口</li><li>vhostHTTPSPort: HTTP请求监听端口</li><li>serverAddr: FRP服务端地址（可以是IP或者是域名）</li><li>serverPort: 服务端与客户端通信端口</li><li>name: 服务端名称，保持唯一即可</li><li>type: 暴露的协议类型</li><li>localIP: 内网需要暴露服务的IP</li><li>localPort: 内网需要暴露服务端口</li><li>customDomains: 暴露服务的自定义域名</li><li>remotePort: 暴露服务的公网访问IP<br>启动FRP服务端：</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">./frps <span class="token parameter variable">-c</span> ./frps.toml</code></pre><p>启动FRP客户端：</p><pre class="language-bash" data-language="bash"><code class="language-bash">./frpc <span class="token parameter variable">-c</span> ./frpc.toml</code></pre><h3 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h3><h4 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h4><ol><li>下载Nginx源码：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://nginx.org/download/nginx-1.23.1.tar.gz</code></pre><ol><li>解压源码：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> nginx-1.23.1.tar.gz</code></pre><ol><li>编译安装：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> nginx-1.23.1./configure<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span></code></pre><ol><li>配置Nginx：</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/nginx/nginx.conf</code></pre><p>配置文件示例：</p><pre class="language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">server_name</span> localhost</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">proxy_pass</span> http://127.0.0.1:8081</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>配置说明：</p><ul><li>listen 80: 监听80端口</li><li>server_name localhost: 服务器名称</li><li>proxy_pass <a href="http://127.0.0.1:8081">http://127.0.0.1:8081</a>: 反向代理到内网服务<br>启动Nginx服务：</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl start nginx</code></pre><h4 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h4><p>CentOS/RedHat：</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> nginx</code></pre><p>Debian/Ubuntu：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> nginx</code></pre><p>配置Nginx：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/nginx/nginx.conf</code></pre><p>配置文件示例：</p><pre class="language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">server_name</span> localhost</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">proxy_pass</span> http://127.0.0.1:8081</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>配置说明：</p><ul><li>listen 80: 监听80端口</li><li>server_name localhost: 服务器名称</li><li>proxy_pass <a href="http://127.0.0.1:8081">http://127.0.0.1:8081</a>: 反向代理到内网服务<br>启动Nginx服务：</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl start nginx</code></pre><h4 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h4><p>在浏览器中输入您的域名或公网IP地址，如果能看到您的内网服务页面，则说明搭建成功。</p><h4 id="Nginx配置文件最佳实践"><a href="#Nginx配置文件最佳实践" class="headerlink" title="Nginx配置文件最佳实践"></a>Nginx配置文件最佳实践</h4><ul><li>所有的 Nginx 配置文件都在 <code>/etc/nginx/</code> 目录下。</li><li>主要的 Nginx 配置文件是 <code>/etc/nginx/nginx.conf</code>。</li><li>为每个域名创建一个独立的配置文件，便于维护服务器。你可以按照需要定义任意多的 block 文件。</li><li>Nginx 服务器配置文件被储存在 <code>/etc/nginx/sites-available</code> 目录下。在 <code>/etc/nginx/sites-enabled</code> 目录下的配置文件都将被 Nginx 使用。</li><li>sites-available 目录用于存储 Nginx 网站的配置文件，这些文件构成了可用的网站列表。若需启用某个网站，可使用符号链接（symlink）将其配置文件从 <code>sites-available</code> 链接到 <code>sites-enabled</code> 目录中。例如，要启用 some.domain.com 网站，可以执行命令 <code>ln -s /etc/nginx/sites-available/some.domain.com /etc/nginx/sites-enabled/</code>。这样，Nginx 便会加载并运行该网站的配置。</li><li>最佳推荐是使用标准的命名方式。例如，如果你的域名是 mydomain.com，那么配置文件应该被命名为 <code>/etc/nginx/sites-available/mydomain.com.conf</code></li><li>如果你在域名服务器配置块中有可重用的配置段，把这些配置段摘出来，做成一小段可重用的配置。</li><li>Nginx 日志文件(access.log 和 error.log)定位在 /var/log/nginx/ 目录下。推荐为每个服务器配置块，配置一个不同的 access 和 error。</li><li>Nginx配置文件在线生成工具：<a href="https://nginxconfig.org/?global.app.lang=zhCN">https://nginxconfig.org/?global.app.lang=zhCN</a></li><li>你可以将你的网站根目录设置在任何你想要的地方。最常用的网站根目录位置包括：</li><li><code>/home/&lt;user_name&gt;/&lt;site_name&gt;</code></li><li><code>/var/www/&lt;site_name&gt;</code></li><li><code>/var/www/html/&lt;site_name&gt;</code></li><li><code>/opt/&lt;site_name&gt;</code></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了如何在服务器上搭建FRP和Nginx服务，并通过FRP将本地服务发布到公网。您可以根据您的需要进行配置和使用。<br>注意：</p><ul><li>为了保证安全，请您在公网IP地址上配置防火墙，只开放必要的端口。</li><li>请您定期更新FRP和Nginx软件版本，以修复已知的安全漏洞。</li><li>本文仅介绍了基本的配置方式，但FRP和Nginx都提供了丰富的个性化配置选项，建议进行高级配置。对于更高级的配置，参考FRP官方文档和Nginx在线配置工具</li><li>在Nginx和FRP的联合配置中，如果Nginx和FRP在同一台服务器上，建议使用hosts文件将FRP内网服务的自定义域名解析为127.0.0.1，以减少防火墙端口暴露，提高安全性</li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>如何使用FRP将多个内网服务发布到公网？<br>您可以通过在frpc配置文件中添加多个 proxies 段来实现。<br>示例：</li></ol><pre class="language-toml" data-language="toml"><code class="language-toml"><span class="token key property">serverAddr</span> <span class="token punctuation">=</span> <span class="token string">"x.x.x.x"</span><span class="token key property">serverPort</span> <span class="token punctuation">=</span> <span class="token number">7000</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token table class-name">proxies</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token key property">name</span> <span class="token punctuation">=</span> <span class="token string">"web"</span><span class="token key property">type</span> <span class="token punctuation">=</span> <span class="token string">"http"</span><span class="token key property">localPort</span> <span class="token punctuation">=</span> <span class="token number">80</span><span class="token key property">localIP</span> <span class="token punctuation">=</span> <span class="token string">"172.17.0.1"</span><span class="token key property">customDomains</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">"www.yourdomain.com"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token table class-name">proxies</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token key property">name</span> <span class="token punctuation">=</span> <span class="token string">"web2"</span><span class="token key property">type</span> <span class="token punctuation">=</span> <span class="token string">"http"</span><span class="token key property">localPort</span> <span class="token punctuation">=</span> <span class="token number">8080</span><span class="token key property">localIP</span> <span class="token punctuation">=</span> <span class="token string">"127.0.0.1"</span><span class="token key property">customDomains</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">"www.yourdomain2.com"</span><span class="token punctuation">]</span></code></pre><ol><li>如何使用Nginx进行负载均衡？<br>您可以通过在Nginx配置文件中添加多个 server 段来实现。<br>示例：</li></ol><pre class="language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">server_name</span> localhost</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">proxy_pass</span> http://127.0.0.1:8080</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">server_name</span> localhost</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">proxy_pass</span> http://127.0.0.1:8081</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol><li>如何使用Nginx进行动静分离？<br>您可以通过在Nginx配置文件中设置 location 来实现。<br>示例：</li></ol><pre class="language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">server_name</span> localhost</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">location</span> /static</span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">root</span> /usr/share/nginx/html/static</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">proxy_pass</span> http://127.0.0.1:8080</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol><li>如何使用FRP进行HTTPS反向代理？<br>您可以通过在FRP服务端配置文件中填写vhostHTTPSPort = 443 客户端填写以下配置<br>示例：</li></ol><pre class="language-toml" data-language="toml"><code class="language-toml"><span class="token key property">serverAddr</span> <span class="token punctuation">=</span> <span class="token string">"x.x.x.x"</span><span class="token key property">serverPort</span> <span class="token punctuation">=</span> <span class="token number">7000</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token table class-name">proxies</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token key property">name</span> <span class="token punctuation">=</span> <span class="token string">"test_htts2http"</span><span class="token key property">type</span> <span class="token punctuation">=</span> <span class="token string">"https"</span><span class="token key property">customDomains</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span><span class="token string">"test.yourdomain.com"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token table class-name">proxies.plugin</span><span class="token punctuation">]</span><span class="token key property">type</span> <span class="token punctuation">=</span> <span class="token string">"https2http"</span><span class="token key property">localAddr</span> <span class="token punctuation">=</span> <span class="token string">"127.0.0.1:80"</span>  <span class="token comment">#本地服务地址</span><span class="token comment"># HTTPS 证书相关的配置</span><span class="token key property">crtPath</span> <span class="token punctuation">=</span> <span class="token string">"./server.crt"</span><span class="token key property">keyPath</span> <span class="token punctuation">=</span> <span class="token string">"./server.key"</span><span class="token key property">hostHeaderRewrite</span> <span class="token punctuation">=</span> <span class="token string">"127.0.0.1"</span><span class="token key property">requestHeaders.set.x-from-where</span> <span class="token punctuation">=</span> <span class="token string">"frp"</span></code></pre><ol><li>如何使用Nginx进行HTTPS反向代理？<br>您可以通过在Nginx配置文件中设置 ssl 字段来实现。<br>示例：</li></ol><pre class="language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">server_name</span> localhost</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">proxy_pass</span> http://127.0.0.1:8080</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">443</span> ssl</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">server_name</span> localhost</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">ssl_certificate</span> /path/to/fullchain.pem</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">ssl_certificate_key</span> /path/to/privkey.pem</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">ssl_protocols</span> TLSv1.2 TLSv1.3</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDHE-RSA-AES128-GCM-SHA256:kEDHE-ECDSA-AES128-GCM-SHA256:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4:!ECDHE-RSA-DES-CBC3-SHA:!ECDHE-ECDSA-DES-CBC3-SHA:!DHE-RSA-DES-CBC3-SHA:!DHE-DSS-DES-CBC3-SHA:!SEED:!IDEA</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">ssl_session_cache</span> builtin:10000</span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">ssl_session_timeout</span> <span class="token number">10m</span></span><span class="token punctuation">;</span>  <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">proxy_set_header</span> Host  <span class="token variable">$http_host</span></span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-Host <span class="token variable">$http_host</span></span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span></span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-Port <span class="token variable">$server_port</span></span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-Proto <span class="token variable">$scheme</span></span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">proxy_http_version</span> 1.1</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">proxy_ssl_server_name</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">proxy_pass</span> http://127.0.0.1:8080</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>FRP官方文档[1]: <a href="https://gofrp.org/zh-cn/">https://gofrp.org/zh-cn/</a></li><li>Nginx官方文档: <a href="https://nginx.org/en/docs/">https://nginx.org/en/docs/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FRP </tag>
            
            <tag> 技术教程 </tag>
            
            <tag> 服务搭建 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识Kubernetes以及与Docker的关系</title>
      <link href="/post/44881/"/>
      <url>/post/44881/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes（k8s）的发展影响着全球IT技术的基础设施平台，也推动了云原生应用、微服务架构、Service Mesh等热门技术的普及和落地。现在，Kubernetes（k8s）已经成为明显项目，其开源项目拥有超过两万名贡献者，成为开源历史上发展速度超快的项目之一。<br><img src="https://media.luckyits.com/obsidian/20240504163844649.png" alt="image.png"></p><h3 id="Kubernetes与Docker的关系"><a href="#Kubernetes与Docker的关系" class="headerlink" title="Kubernetes与Docker的关系"></a>Kubernetes与Docker的关系</h3><p>通常，我们会把Kubernetes（k8s）看作Docker的上层架构，就好像Java与J2EE的关系一样：J2EE是以Java为基础的企业级软件架构，Kubernetes（k8s）则以Docker为基础打造了一个云计算时代的全新分布式系统架构。但Kubernetes（k8s）与Docker之间还存在着更为复杂的关系，从表面上看，似乎Kubernets（k8s）离不开Docker，但实际上在Kubernetes（k8s）的架构里，Docker只是其目前支持的两种底层容器技术之一，另一种容器技术则是Rocket，Rocker为CentOS退出的竞争产品。</p><h3 id="Kubernetes是什么"><a href="#Kubernetes是什么" class="headerlink" title="Kubernetes是什么"></a>Kubernetes是什么</h3><p>首先，它是一个全新的基于容器技术的分布式架构领先方案。这个方案虽然还很新，但它是谷歌十几年以来大规模应用容器技术的经验积累和升华的重要成果。确切地说，Kubernetes（k8s）是谷歌严格保密十几年的秘密武器—Borg的一个开源版本。Borg是谷歌的一个久负盛名的内部使用的大规模集群管理系统。它基于容器技术，目的是实现资源管理的自动化，以及跨多个数据中心的资源利用率的最大化。</p><p>十几年以来，谷歌一直通过Borg系统管理着数量庞大的应用程序集群。由于谷歌员工都签署了保密协议，即便离职也不能泄露Borg的内部设计，所以外界一直无法了解关于它的更多信息。直到2015年4月，传闻许久的Borg论文伴随Kubernetes的高调宣传被谷歌首次公开，大家才得以了解它的更多内幕。正是由于站在Borg这个前辈的肩膀上，汲取了Borg过去十年间的经验与教训，所以Kubernetes（k8s）一经开源就一鸣惊人，并迅速称霸容器领域。<br><img src="https://media.luckyits.com/obsidian/20240504163929530.png" alt="image.png"><br>其次，如果我们系统设计遵循了Kubernetes的设计思想，那么就不必考虑传统的系统架构中的业务跟底层代码以及功能模块，不必枉费心思考虑负载均衡跟部署实施的问题。总之使用Kubernetes提供的解决方案，不仅可以节省不少于30%的开发成本，还可以将精力集中于业务本身。而且由于Kubernetes提供了强大的自动化机制，所以系统后期的运维成本跟难度会大幅度降低。</p><p>然后，Kubernetes是一个开放的开发平台。与J2EE不同，它不局限于任何一种编程语言，没有限定任何编程接口，所以不论用什么语言编写的服务，都可以被映射为Kubernetes的Service（服务），并通过标准的TCP协议进行交互。此外，Kubernetes平台对现有的编程语言、编程框架、中间件没有任何侵入性，因此现有的系统也很容易改造升级并迁移到Kubernetes平台上。</p><p>最后Kubernetes是一个完备的分布式系统支撑平台。Kubernetes具有完备的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制。同时，Kubernetes提供了完善的管理工具。</p><h3 id="Kubernetes的基本概念"><a href="#Kubernetes的基本概念" class="headerlink" title="Kubernetes的基本概念"></a>Kubernetes的基本概念</h3><p>在Kubernetes中，Service是分布式集群架构的核心，一个Service对象拥有如下关键特征。  </p><ul><li>拥有唯一指定名称（比如mysql-server）。</li><li>拥有一个虚拟IP（Cluster IP、Service IP 或 VIP）和端口号。</li><li>能够提供某种远程服务能力。</li><li>被映射到提供这种服务能力的一组容器应用上。</li></ul><p>Service的服务进程目前都基于Socket通信方式对外提供服务，比如Redis、Memcachhe、MySQL、Web Server，或者是实现了某个具体业务的特定TCP Server进程。虽然一个Service通常由多个相关的服务进程提供服务，每个服务进程都有一个独立的Endpoint（IP+Port）访问点，但Kubernetes能够让我们通过Service（虚拟Cluster IP + Service Port）连接到指定的Service</p><p>容器提供了强大的隔离功能，所以有必要把为Service提供服务的这组进程放入容器中进行隔离。为此，Kubernetes设计了Pod对象，将每个服务进程都包装到相应的Pod中，使其为在Pod中运行的一个容器（Container）</p><p>这里先简单介绍一下Pod的概念。首先，Pod运行在一个被称为节点（Node）的环境中，这个节点既可以是物理机，也可以是私有云或者公有云中的一个虚拟机，通常一个节点上运行几百个Pod；其次，在每个Pod中都运行着一个特殊的被称为Pause的容器，其他容器则为业务容器，这些业务容器共享Pause容器的网络栈和Volume挂载卷，因此它们之间的通信和数据交换更为高效，在设计时我们可以利用这一特性把密切相关的服务进程放入同一个Pod中；最后需要注意的是，并不是每个Pod和它里面运行的容器都能被映射到一个Service上，只有提供服务（无论是对内还是对外）的那组Pod才会被映射为一个服务。<br><img src="https://media.luckyits.com/obsidian/20240504164008527.png" alt="image.png"><br>Kubernetes为传统IT系统的扩容和服务升级提供了全新的解决思路。在Kubernetes集群中，只需为需要扩容的Service关联的Pod创建一个RC （Replication Controller），服务扩容以至服务升级等令人头疼的问题都迎刃而解。在一个RC定义文件中包括以下3个关键信息。</p><ul><li>目标Pod的定义</li><li>目标Pod需要运行的副本数量（Replicas）</li><li>要监控的目标Pod的标签</li></ul><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本文主要是关于Kubernetes（k8s）的一些基本概念的介绍，后续还有其他像了解的内容可以在文章下发留言，尽量为大家写出来。也很欢迎各位大佬的斧正。</p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Docker </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows安装Scoop</title>
      <link href="/post/61991/"/>
      <url>/post/61991/</url>
      
        <content type="html"><![CDATA[<p>通过以下命令，可以将Scoop安装到默认目录（ C:\Users\<username>\scoop）：</username></p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">Invoke-Expression</span> <span class="token punctuation">(</span><span class="token function">New-Object</span> System<span class="token punctuation">.</span>Net<span class="token punctuation">.</span>WebClient<span class="token punctuation">)</span><span class="token punctuation">.</span>DownloadString<span class="token punctuation">(</span><span class="token string">'https://get.scoop.sh'</span><span class="token punctuation">)</span></code></pre><p>或者另一条更短的命令：</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">iwr</span> <span class="token operator">-</span>useb get<span class="token punctuation">.</span>scoop<span class="token punctuation">.</span>sh <span class="token punctuation">|</span> <span class="token function">iex</span></code></pre><p>如果你需要更改默认的安装目录，则需要在执行以上命令前添加环境变量的定义，通过执行以下命令完成：</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token variable">$env</span>:SCOOP=<span class="token string">'D:\Applications\Scoop'</span><span class="token namespace">[Environment]</span>::SetEnvironmentVariable<span class="token punctuation">(</span><span class="token string">'SCOOP'</span><span class="token punctuation">,</span> <span class="token variable">$env</span>:SCOOP<span class="token punctuation">,</span> <span class="token string">'User'</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scoop </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows11迁移Docker到其他磁盘</title>
      <link href="/post/4080/"/>
      <url>/post/4080/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-for-Windows-的安装"><a href="#Docker-for-Windows-的安装" class="headerlink" title="Docker for Windows 的安装"></a>Docker for Windows 的安装</h2><div class="note info modern"><p><strong><span class="p red">注意</span></strong>：此篇文章所讲述的镜像迁移方法已不具参考意义，因为Windows桌面版 docker 已能够支持自定义路径了。</p></div><p><img src="https://img.luckyits.com/2024/06/07/66630241a8b4d.webp" alt="docker镜像设置"></p><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。————摘自百度百科</p><blockquote><p>先声明一下文章是自己以前在百家号写的，抄自己应该不算抄吧🤣</p></blockquote><p>Docker Desktop for Windows 支持 64 位版本的 Windows 10 Pro，且必须开启 Hyper-V（若版本为 v1903 及以上则无需开启 Hyper-V），或者 64 位版本的 Windows 10 Home v1903 及以上版本</p><p>在官网下载好之后双击 Docker Desktop Installer.exe 开始安装</p><h2 id="Docker-for-Windows-镜像迁移（WSL2安装）"><a href="#Docker-for-Windows-镜像迁移（WSL2安装）" class="headerlink" title="Docker for Windows 镜像迁移（WSL2安装）"></a>Docker for Windows 镜像迁移（WSL2安装）</h2><p>在Windows11中默认已安装Windows Terminal 推荐使用其操作Docker，打开Windows Terminal 输入命令 <code>wsl -l --all -v</code> 来查看Docker的运行状态</p><p><img src="https://media.luckyits.com/obsidian/20240503220508500.png" alt="image.png"></p><p>执行命令之后可以看到如上图所示Docker的运行状态，Running表示正在运行中，使用 <code>wsl --shutdown</code> 关闭运行中的Docker</p><p><img src="https://media.luckyits.com/obsidian/20240503220703265.png" alt="image.png"></p><p>再次运行命令可以查看到Docker已处于停止状态，此时就可以进入镜像迁移的步骤。</p><p><img src="https://media.luckyits.com/obsidian/20240503220759613.png" alt="image.png"></p><ol><li>导出Docker镜像</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">wsl <span class="token parameter variable">--export</span> docker-desktop-data <span class="token string">"D:\wsl\docker-data\docker-desktop-data.tar"</span>wsl <span class="token parameter variable">--export</span> docker-desktop <span class="token string">"D:\docker\docker-desktop.tar"</span></code></pre><ol><li>注销镜像</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">wsl <span class="token parameter variable">--unregister</span> docker-desktopwsl <span class="token parameter variable">--unregister</span> docker-desktop-data</code></pre><ol><li>导入之前导出的镜像</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">wsl <span class="token parameter variable">--import</span> docker-desktop d:<span class="token punctuation">\</span>docker<span class="token punctuation">\</span>docker-desktop d:<span class="token punctuation">\</span>docker<span class="token punctuation">\</span>docker-desktop.tarwsl <span class="token parameter variable">--import</span> docker-desktop-data d:<span class="token punctuation">\</span>docker<span class="token punctuation">\</span>docker-desktop-data </code></pre><p>重启Docker</p><ol><li>验证</li></ol><p>进入导入的目录下载一个Docker镜像可以看见导入镜像文件大小的的变化，说明导入成功。</p><p><img src="https://media.luckyits.com/obsidian/20240503221141171.png" alt="image.png"></p><h2 id="Docker-for-Windows-镜像迁移（Windows符号连接方式）"><a href="#Docker-for-Windows-镜像迁移（Windows符号连接方式）" class="headerlink" title="Docker for Windows 镜像迁移（Windows符号连接方式）"></a>Docker for Windows 镜像迁移（Windows符号连接方式）</h2><p>Docker for Windows 安装完成之后会在C盘的用户目录下生成镜像，如下图所示，在对应的位置下存有Docker的镜像。</p><p><img src="https://media.luckyits.com/obsidian/20240503221238110.png" alt="image.png"></p><p>在知道Docker的目录之后，可以通过Windows符号连接的方式提前创建Docker对应目录的符号连接。</p><p>使用命令 <code>mklink /D "创建符号连接的目录" "实际存储的目录"</code> 创建完成之后执行Docker安装，镜像会直接安装到对应的位置。</p><p><img src="https://media.luckyits.com/obsidian/20240503221400096.png" alt="image.png"></p><p><img src="https://media.luckyits.com/obsidian/20240503221432548.png" alt="image.png"></p><h2 id="Docker-for-Windows-加速镜像"><a href="#Docker-for-Windows-加速镜像" class="headerlink" title="Docker for Windows 加速镜像"></a>Docker for Windows 加速镜像</h2><p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p><p>科大镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn/</a></p><p>网易：<a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com/</a></p><p>阿里云：https://&lt;你的ID&gt;.mirror.aliyuncs.com</p><p>七牛云加速器：<a href="https://reg-mirror.qiniu.com">https://reg-mirror.qiniu.com</a></p><p><img src="https://media.luckyits.com/obsidian/20240503220322711.png" alt="docker"></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Docker </tag>
            
            <tag> Windows11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高你的工作效率，高效本地检索工具Listary跟Everything</title>
      <link href="/post/34919/"/>
      <url>/post/34919/</url>
      
        <content type="html"><![CDATA[<p>正在刷漫威的途中，朋友发来消息说 Wndows7 的搜索功能不好使了。Window7 的搜索相信大家都有所体验。本地搜索功能速度之慢让人无力吐槽（不知道他是怎么一直用的这个让人无力吐槽的自带搜索功能的）。也没想太多就开始着手帮忙解决问题，然而毕竟国内大环境如此，朋友使用的 Ghost 版的 Windows7，指导一个电脑小白去在这样的系统上去解决问题，简直不要太麻烦！:wulian:</p><p>  既然问题找上门来了，总不能不帮忙解决吧！幸好，这个世上牛人多，神人们也多，制作了一个又一个的神器，着实提升了我等 P 民的工作效率和生活质量。最终为他提供了一种代替的解决方案，也就是今天要为大家推荐的高效检索工作之一的 <a href="https://www.voidtools.com/zh-cn/" title="点击直达官网">Everything</a>，解决了本地检索的问题。别问为什么一开始不直接推荐，而是折腾半天之后才给出替代方案的，因为我想的是尽量不改变别人的工作方式，毕竟软件也是需要简单学习一下高效使用方式的！废话有点过多了，下面开始为大家介绍这我使用比较多的两款高效搜索工具 <a href="https://www.voidtools.com/zh-cn/" title="点击直达官网">Everything</a> 跟 <a href="https://www.listary.com/" title="点击直达官网">Listary</a>。</p><h2 id="Listary-是什么？"><a href="#Listary-是什么？" class="headerlink" title="Listary 是什么？"></a>Listary 是什么？</h2><p>  Listary 在维基百科中是这样介绍的：</p><blockquote><p><strong>Listary 介绍</strong><br><strong>Listary</strong>是一款用于 <a href="https://zh.wikipedia.org/wiki/Microsoft_Windows" title="Microsoft Windows">Windows</a> 的文件名定位/搜索辅助软件。它为 Windows 传统低效的文件打开/保存对话框提供了便捷、人性化的文件（夹）定位方式，同时改善了常见 <a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8" title="文件管理器">文件管理器</a> 中文件夹切换的效率。<br><br><strong>与 Everything 的比较</strong> <br><br>许多用户都将 Listary 与 Everything 进行比较甚至视为同类软件，实际上从前面的功能说明可以看出它们除了创建索引的方法相似外，实际上几乎没有共同点。例如两者的定位：Everything 的定位为替代传统的本地搜索工具，如 <a href="https://zh.wikipedia.org/wiki/Google%E6%A1%8C%E9%9D%A2" title="Google桌面">Google桌面</a>，Listary 则为基于搜索的文件定位与操作和文件夹切换辅助工具。</p></blockquote><h2 id="为什么用-Listary"><a href="#为什么用-Listary" class="headerlink" title="为什么用 Listary"></a>为什么用 Listary</h2><p>  工欲善其事，必先利其器，得益于 Windows 对 NTFS 的支持并利用了 Windows 提供的 API 支持获取所有文件列表，能输入瞬间返回全盘的匹配文件，且功能丰富，上手简单。打个比方：你同时几天前发给你一些文档，你直接接收了。当你要用的时候放在哪了发现没一点印象，但是你大概记住了文件的名字，那么你只需要按下两次 Ctrl 键，弹出搜索框输入你记住的名字，就可以检索出所有的包含你输入的这个文件名字的所有文件。</p><div style="text-align:center"> ![1.gif](https://media.luckyits.com/obsidian/202307052108653.gif)</div><p></p><p>可以看到瞬间列出了所有跟检索文字有关的文件。如果你是因为懒散不知道将文件放到何处了，那么这款软件就能很好的解决这个问题。当然 Listary 的强大之处冰不止这些，除了可以本地检索快速定位文件，还可以在桌面直接进行文件搜索。<img src="https://media.luckyits.com/obsidian/202307052107587.gif" alt="2.gif">&lt;/div&gt;</p><p>除了在本地搜索以外，还可以直接进行百度或者 Google 等搜索引擎的检索，更多功能大家可去深入发掘，比如可以自定义快捷键直接进行淘宝商品检索等。Listary 还退出了 Pro 版本，需要付费，个人觉得免费版已经可以应付日常使用了，没有必要非上专业版。Pro 版本中增加了文件工作流，如果不是深度使用此软件，免费版本主可以应付。<a href="https://www.listary.com/pro" title="点击直达官网">这里查看区别</a></p><p><img src="https://media.luckyits.com/obsidian/202307052110711.gif" alt="3.gif">&lt;/div&gt;</p><h2 id="Everything-是什么？"><a href="#Everything-是什么？" class="headerlink" title="Everything 是什么？"></a>Everything 是什么？</h2><p>  关于 Everything 的介绍同样的给大家搬运一下维基百科的介绍：</p><blockquote><p><strong>Everything</strong>是一个 <a href="https://zh.wikipedia.org/wiki/%E4%B8%93%E6%9C%89%E8%BD%AF%E4%BB%B6" title="专有软件">私有的</a><a href="https://zh.wikipedia.org/wiki/%E5%85%8D%E8%B4%B9%E8%BD%AF%E4%BB%B6" title="免费软件">免费</a>Windows<a href="https://zh.wikipedia.org/wiki/%E6%A1%8C%E9%9D%A2%E6%90%9C%E7%B4%A2" title="桌面搜索">桌面搜索引擎</a>，可以在 <a href="https://zh.wikipedia.org/wiki/NTFS" title="NTFS">NTFS</a> 卷上快速地根据名称查找文件和目录。由澳大利亚人大卫·卡彭特（David Carpenter）开发。2009 年 10 月 30 日，在拥有 70,000 用户的 <a href="https://zh.wikipedia.org/wiki/Wakoopa" title="Wakoopa">Wakoopa</a> 网站排名中，Everything 在 1757 个应用程序中排名第 857，超越了老牌压缩工具 <a href="https://zh.wikipedia.org/wiki/WinZip" title="WinZip">WinZip</a>。直到 2013 年，Everything 仍处于开发状态。</p></blockquote><h2 id="为什么用-Everything？"><a href="#为什么用-Everything？" class="headerlink" title="为什么用 Everything？"></a>为什么用 Everything？</h2><p>  Everything 非常小巧，安装包仅有 1.3M，运行时占用资源也极低。搜索速度非常快，Windows10 搜索一个文件 1 分钟之后找出了 3 个文件，并且还在继续搜索。而 Everything 搜索仅用了 1 秒。并且 Everyting 这款软件完全免费。同时软件还提供便携版本的下载，该软件首次使用会建立一次索引，大概几秒钟的时间，建立完成之后就可以进行本地化的快速检索。<img src="https://media.luckyits.com/obsidian/202307052110790.gif" alt="5.gif">&lt;/div&gt;</p><p>  Everything 能在 Windows XP、Vista、Windows 7、Windows 8 和 Windows 10 Windows11 上运行。NTFS 索引功能需要 Everything 服务或用管理员方式打开 Everything。更多的使用方式大家可以查看官网的 <a href="https://www.voidtools.com/zh-cn/support/everything/" title="点击直达">帮助文档</a></p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p>Listary 下载地址：<a href="https://www.listary.com/download" title="点击直达">官网下载</a>  <a href="https://pan.baidu.com/s/1t3H0GlyE2LCesZYXFZkm9g" title="点击直达">百度云</a>  提取码：ulqp</p><p>Everything 下载地址：<a href="https://www.voidtools.com/zh-cn/downloads/" title="点击直达">官网下载</a>  <a href="https://pan.baidu.com/s/1t3H0GlyE2LCesZYXFZkm9g" title="点击直达">百度云</a>  提取码：ulqp</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  高效办公的工具有很多，这里为大家推荐了这两款高效搜索的软件，虽然现在 Windows 的搜索有了很大的进步，但是效率还是没有这两款软件高，当然检索工具远不止这两个，还有更多的高效软件等着大家去发掘。我推荐的这两款软件的区别主要在于 Everything 侧重于文件搜索，Listary 侧重于文件定位，前者适合电脑党，后者更适合文件深度管理用户。</p>]]></content>
      
      
      <categories>
          
          <category> 工具推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Listary </tag>
            
            <tag> Everything </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Linux命令</title>
      <link href="/post/3397/"/>
      <url>/post/3397/</url>
      
        <content type="html"><![CDATA[<p>整理的 DevOps 人员常用的命令罗列出来，建立了一个速查表供大家参考！方便大家进行快速查看，节省搜索时间！这里只是一些基础的命令，其他内容可以访问<a href="https://ref.luckyits.com">命令速查</a>内容更全,而且会持续更新！</p><style>table td:first-of-type {width: 106px;}table td:nth-of-type(2) {width: 694px;}</style><h3 id="线上查询及帮助命令"><a href="#线上查询及帮助命令" class="headerlink" title="线上查询及帮助命令"></a>线上查询及帮助命令</h3><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>help</code></td><td style="text-align:left">help命令用于显示内置命令的帮助 —help也可使用</td></tr><tr><td style="text-align:left"><code>man</code></td><td style="text-align:left">当你需要查看某个命令的参数时不必到处上网查找，只要man一下即可，命令词典，更复杂的还有info，但不常用</td></tr></tbody></table></div><h3 id="文件和目录操作命令"><a href="#文件和目录操作命令" class="headerlink" title="文件和目录操作命令"></a>文件和目录操作命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>cd</code></td><td>全拼 change directory，命令用于切换当前工作目录至 dirName(目录参数)。</td></tr><tr><td><code>cp</code></td><td>全拼 copy，其功能是复制文件或者目录。</td></tr><tr><td><code>find</code></td><td>查找文件，Linux下非常重要的一条命令，在目录结构中进行搜索</td></tr><tr><td><code>mkdir</code></td><td>全拼 make directories，建立目录</td></tr><tr><td><code>mv</code></td><td>全拼 move 用来移动文件或者将文件改名（move (rename) files），经常用来备份文件或者目录。</td></tr><tr><td><code>pwd</code></td><td>全拼 print working directory，执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称</td></tr><tr><td><code>rename</code></td><td>使用指定的替换项替换其名称中的搜索表达式来重命名给定的文件（可批量重命名）</td></tr><tr><td><code>rm</code></td><td>全拼 remove 用于删除一个文件或者目录。</td></tr><tr><td><code>rmdir</code></td><td>全拼 remove empty directories，删除空目录。</td></tr><tr><td><code>touch</code></td><td>修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</td></tr><tr><td><code>tree</code></td><td>执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件（树状结构）</td></tr><tr><td><code>basename</code></td><td>获取路径中的文件名或路径名，还可以对末尾字符进行删除</td></tr><tr><td><code>dirname</code></td><td>去除包含绝对路径文件中的文件名，返回目录的部分</td></tr><tr><td><code>chattr</code></td><td>查看和改变文件目录属性</td></tr><tr><td><code>lsattr</code></td><td>显示文件属性</td></tr><tr><td><code>file</code></td><td>辨识文件类型</td></tr><tr><td><code>md5sum</code></td><td>计算和校验文件MD5值的工具程序</td></tr></tbody></table></div><h3 id="查看文件及内容处理命令"><a href="#查看文件及内容处理命令" class="headerlink" title="查看文件及内容处理命令"></a>查看文件及内容处理命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>cat</td><td>全拼 concatenate， 命令用于连接文件并打印到标准输出设备上（由第一行开始显示）</td></tr><tr><td>tac</td><td>tac是cat的反向拼写，从最后一行倒序显示内容，并将所有内容输出</td></tr><tr><td>more</td><td>命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读</td></tr><tr><td>less</td><td>与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件</td></tr><tr><td>head</td><td>见名知意，显示文件的头部，默认显示前 10 行，如果不止一个文件，则在显示的每个文件前面加一个文件名标题。</td></tr><tr><td>tail</td><td>将某个文件最后几行显示在终端上，如果有更新tail会自动刷新，tail -f实时显示追加的内容</td></tr><tr><td>cut</td><td>显示每行从开头算起 num1 到 num2 的文字</td></tr><tr><td>split</td><td>用于将一个文件分割成数个</td></tr><tr><td>paste</td><td>按照行合并内容</td></tr><tr><td>sort</td><td>用于将文本文件内容加以排序，sort可针对文本文件的内容，以行为单位来排序。</td></tr><tr><td>uniq</td><td>用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用</td></tr><tr><td>wc</td><td>统计文件的行数、单词数量或者是字数。（不是卫生间trollface ）</td></tr><tr><td>iconv</td><td>转换文件的编码格式</td></tr><tr><td>dos2unix</td><td>将Windows格式文件转换为Unix、Linux格式的实用命令</td></tr><tr><td>diff</td><td>全拼 difference，最简单的情况下，比较两个文件的不同</td></tr><tr><td>vimdiff</td><td>命令行可视化文本对比工具，常用于文本对比合并</td></tr><tr><td>rev</td><td>将文件中的每行内容以字符为单位反序输出，即第一个字符最后输出，最后一个字符最先输出，依次类推。</td></tr><tr><td>grep/egrep</td><td>过滤字符串，三剑客老三（在文件内查找指定的字符串）</td></tr><tr><td>join</td><td>根据相同字段合并两个文件</td></tr><tr><td>tr</td><td>转换或删除文件中的字符</td></tr><tr><td>vi/vim</td><td>命令文本编辑器（很常用）</td></tr></tbody></table></div><h3 id="文件压缩及解压缩命令"><a href="#文件压缩及解压缩命令" class="headerlink" title="文件压缩及解压缩命令"></a>文件压缩及解压缩命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>tar</td><td>打包压缩</td></tr><tr><td>unzip</td><td>解压文件</td></tr><tr><td>gzip</td><td>gzip压缩工具</td></tr><tr><td>zip</td><td>压缩工具</td></tr></tbody></table></div><h3 id="信息显示命令"><a href="#信息显示命令" class="headerlink" title="信息显示命令"></a>信息显示命令</h3><table class="table table-bordered table-striped table-condensed"><tbody><tr><td>uname</td><td>显示操作系统相关信息的命令</td></tr><tr><td>hostname</td><td>设置或者显示系统主机名，没有任何参数就会返回gethostname()函数的返回值</td></tr><tr><td>dmesg</td><td>显示开机信息</td></tr><tr><td>uptime</td><td>命令告诉你系统启动up了（运行了）多长时间以及系统负载</td></tr><tr><td>stat</td><td>用于显示文件或文件系统的详细信息</td></tr><tr><td>du</td><td>显示指定的目录或文件所占用的磁盘空间</td></tr><tr><td>df</td><td>显示目前在Linux系统上的文件系统的磁盘使用情况统计</td></tr><tr><td>top</td><td>实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器</td></tr><tr><td>free</td><td>显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存</td></tr><tr><td>date</td><td>显示或设定系统的日期与时间</td></tr><tr><td>cal</td><td>显示指定月份的日历</td></tr></tbody></table><h3 id="搜索文件命令"><a href="#搜索文件命令" class="headerlink" title="搜索文件命令"></a>搜索文件命令</h3><table class="table table-bordered table-striped table-condensed"><tbody><tr><td>which</td><td>which指令会在环境变量$PATH设置的目录里查找符合条件的文件</td></tr><tr><td>find</td><td>查找文件，Linux下非常重要的一条命令，在目录结构中进行搜索。</td></tr><tr><td>whereis</td><td>跟which功能相同，但该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。</td></tr><tr><td>locate</td><td>locate命令要比find -name快得多，原因在于它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db 。这个数据库中含有本地所有文件信息</td></tr></tbody></table><h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><table class="table table-bordered table-striped table-condensed"><tbody><tr><td>useradd</td><td>添加用户</td></tr><tr><td>usermod</td><td>修改用户帐号的各项设定</td></tr><tr><td>userdel</td><td>删除用户</td></tr><tr><td>groupadd</td><td>添加用户组</td></tr><tr><td>passwd</td><td>修改用户密码</td></tr><tr><td>chage</td><td>修改用户密码有效期</td></tr><tr><td>id</td><td>id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。</td></tr><tr><td>su</td><td>切换用户</td></tr><tr><td>vissudo</td><td>编辑/etc/sudoers文件的专属命令</td></tr><tr><td>sudo</td><td>命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。（在 /etc/sudoers 中有出现的使用者）</td></tr></tbody></table><h3 id="基础网络操作命令"><a href="#基础网络操作命令" class="headerlink" title="基础网络操作命令"></a>基础网络操作命令</h3><table class="table table-bordered table-striped table-condensed"><tbody><tr><td>telnet</td><td>执行telnet指令使用TELNET协议登入远端主机</td></tr><tr><td>ssh</td><td>远程登录用于远程登录上Linux主机</td></tr><tr><td>scp</td><td>全拼 secure copy，用于不同主机之间复制文件</td></tr><tr><td>wget</td><td>命令下载文件</td></tr><tr><td>ping</td><td>测试网络主机之间的连通性</td></tr><tr><td>route</td><td>显示和设置Linux系统的路由表</td></tr><tr><td>ifconfig</td><td>查看、配置、启用或者禁用网络接口的命令。（不要跟Windows的ipconfig记混）</td></tr><tr><td>ifup</td><td>启动网卡</td></tr><tr><td>ifdown</td><td>关闭网卡</td></tr><tr><td>netstat</td><td>查看网络状态</td></tr><tr><td>ss</td><td>跟netstat功能相同</td></tr></tbody></table><h3 id="网络操作命令进阶"><a href="#网络操作命令进阶" class="headerlink" title="网络操作命令进阶"></a>网络操作命令进阶</h3><table class="table table-bordered table-striped table-condensed"><tbody><tr><td>nmap</td><td>全拼 network mapper 是Linux下的网络扫描和嗅探工具包，网络扫描命令</td></tr><tr><td>lsof</td><td>全拼 list open files 查看进程打开的文件</td></tr><tr><td>mail</td><td>邮件发送和接收命令</td></tr><tr><td>mutt</td><td>邮件管理命令</td></tr><tr><td>nslookup</td><td>查看DNS信息</td></tr><tr><td>dig</td><td>查询DNS包括NS记录，A记录，MX记录等相关信息</td></tr><tr><td>host</td><td>查询域名、检查域名解析是否正确</td></tr><tr><td>traceroute</td><td>跟踪主机路由</td></tr><tr><td>tcpdump</td><td>对网络上的数据包进行截获的包分析工具</td></tr></tbody></table><h3 id="关于磁盘跟文件系统的命令"><a href="#关于磁盘跟文件系统的命令" class="headerlink" title="关于磁盘跟文件系统的命令"></a>关于磁盘跟文件系统的命令</h3><table class="table table-bordered table-striped table-condensed"><tbody><tr><td>mount</td><td>用于挂载Linux系统外的文件</td></tr><tr><td>umount</td><td>可卸除目前挂在Linux目录中的文件系统</td></tr><tr><td>fsck</td><td>检查与修复 Linux 档案系统，可以同时检查一个或多个 Linux 档案系统</td></tr><tr><td>dd</td><td>指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换</td></tr><tr><td>dumpe2fs</td><td>查看格式化之后的文件系统信息</td></tr><tr><td>dump</td><td>使用“备份级别”来实现增量备份，它支持 0～9 共 10 个备份级别（备份分区、文件或目录）</td></tr><tr><td>fdisk</td><td>创建和维护分区表，兼容DOS类型的分区表、BSD或者SUN类型的磁盘列表。适用于2TB以下磁盘分区</td></tr><tr><td>parted</td><td>规划大小超过2T的分区，也可用于小分区的规划</td></tr><tr><td>mkfs</td><td>用来在特定的分区建立Linux文件系统（格式化创建Linux文件系统）</td></tr><tr><td>partprobe</td><td>通知操作系统内核分区表更改，通过请求操作系统重新读取分区表</td></tr><tr><td>e2fsck</td><td>用于检查使用 Linux ext2 档案系统的 partition 是否正常工作。</td></tr><tr><td>mkswap</td><td>创建交换分区</td></tr><tr><td>swapon</td><td>启用交换分区</td></tr><tr><td>swapoff</td><td>关闭交换分区</td></tr><tr><td>sync</td><td>用于数据同步,sync命令是在关闭Linux系统时使用的（将内存的数据写入磁盘）</td></tr><tr><td>resize2fs</td><td>调整ext文件系统的空间大小</td></tr></tbody></table><h3 id="关于用户授权跟系统权限的命令"><a href="#关于用户授权跟系统权限的命令" class="headerlink" title="关于用户授权跟系统权限的命令"></a>关于用户授权跟系统权限的命令</h3><table class="table table-bordered table-striped table-condensed"><tbody><tr><td>chmod</td><td>修改文件或者目录权限</td></tr><tr><td>chown</td><td>利用 chown 将指定文件的拥有者改为指定的用户或组</td></tr><tr><td>chgrp</td><td>使用chgrp指令取变更文件与目录所属群组（更改文件用户组）</td></tr><tr><td>umask</td><td>指定在建立文件时预设的权限掩码（显示或者隐藏）</td></tr></tbody></table><h3 id="查看系统用户登录信息命令"><a href="#查看系统用户登录信息命令" class="headerlink" title="查看系统用户登录信息命令"></a>查看系统用户登录信息命令</h3><table class="table table-bordered table-striped table-condensed"><tbody><tr><td>whoami</td><td>用于显示自身用户名称，相当于执行id -un命令</td></tr><tr><td>who</td><td>用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</td></tr><tr><td>w</td><td>执行这项指令可得知目前登入系统的用户有哪些人，以及他们正在执行的程序。</td></tr><tr><td>last</td><td>显示近期用户或终端的登录情况</td></tr><tr><td>lastlog</td><td>检查某用户上次登录时间</td></tr><tr><td>users</td><td>显示当前登录系统的所有用户</td></tr><tr><td>finger</td><td>用来查找并显示用户信息，系统管理员通过使用该命令可以知道某个时候到底有多少用户在使用这台Linux主机。</td></tr></tbody></table><h3 id="内置命令及其他"><a href="#内置命令及其他" class="headerlink" title="内置命令及其他"></a>内置命令及其他</h3><table class="table table-bordered table-striped table-condensed"><tbody><tr><td>echo</td><td>用于字符串的输出</td></tr><tr><td>printf</td><td>主要作用是输出文本，按照我们指定的格式输出文本</td></tr><tr><td>rpm</td><td>RPM软件包的管理工具</td></tr><tr><td>yum</td><td>是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器</td></tr><tr><td>watch</td><td>可以监测一个命令的运行结果</td></tr><tr><td>alias</td><td>设置系统别名</td></tr><tr><td>unalias</td><td>取消系统别名</td></tr><tr><td>date</td><td>查看或者设置系统时间</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>history</td><td>查看命令执行的历史记录</td></tr><tr><td>eject</td><td>弹出光驱</td></tr><tr><td>time</td><td>获取到一个程序的执行时间</td></tr><tr><td>nc</td><td>实现任意TCP/UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口（功能强大的网络工具）</td></tr><tr><td>xargs</td><td>给命令传递参数的一个过滤器，也是组合多个命令的一个工具</td></tr><tr><td>exec</td><td>调用并执行指令的命令</td></tr><tr><td>export</td><td>设置或者显示环境变量</td></tr><tr><td>unset</td><td>unset为shell内建指令，可删除变量或函数</td></tr><tr><td>type</td><td>一般情况下，type命令被用于判断另外一个命令是否是内置命令，但是它实际上有更多的用法</td></tr><tr><td>bc</td><td>命令行科学计算器</td></tr></tbody></table><h3 id="系统管理与性能监视命令"><a href="#系统管理与性能监视命令" class="headerlink" title="系统管理与性能监视命令"></a>系统管理与性能监视命令</h3><table class="table table-bordered table-striped table-condensed"><tbody><tr><td>chkconfig</td><td>管理Linux系统开机启动项</td></tr><tr><td>vmstat</td><td>全拼 virtual meomory statistics (虚拟内存缩写)虚拟内存统计</td></tr><tr><td>mpstat</td><td>mpstat是 Multiprocessor Statistics的缩写，是实时系统监控工具</td></tr><tr><td>iostat</td><td>iostat工具将对系统的磁盘操作活动进行监视</td></tr><tr><td>sar</td><td>全拼 system activity reporter（系统活动情况报告）是目前 Linux 上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况、 系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等</td></tr><tr><td>ipcs</td><td>提供关于一些进程间通信方式的信息，包括共享内存，消息队列，信号</td></tr><tr><td>ipcrm</td><td>删除消息队列、信号集、或者共享内存标识</td></tr><tr><td>strace</td><td>strace能帮助你追踪到一个程序所执行的系统调用</td></tr><tr><td>ltrace</td><td>用来跟踪进程调用库函数的情况</td></tr></tbody></table><h3 id="关机-重启-注销和查看系统信息命令"><a href="#关机-重启-注销和查看系统信息命令" class="headerlink" title="关机\重启\注销和查看系统信息命令"></a>关机\重启\注销和查看系统信息命令</h3><table class="table table-bordered table-striped table-condensed"><tbody><tr><td>shutdown</td><td>关机</td></tr><tr><td>halt</td><td>与shutdown功能相同</td></tr><tr><td>poweroff</td><td>关闭电源</td></tr><tr><td>logout</td><td>退出系统</td></tr><tr><td>exit</td><td>退出目前的shell</td></tr><tr><td>ctrl+d</td><td>退出当前登录的Shell的快捷键</td></tr></tbody></table><h3 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h3><table class="table table-bordered table-striped table-condensed"><tbody><tr><td>bg</td><td>将一个在后台暂停的命令，变成继续执行</td></tr><tr><td>fg</td><td>将后台中的命令调至前台继续运行</td></tr><tr><td>jobs</td><td>将当前的程序挂载</td></tr><tr><td>kill</td><td>发送指定的信号到相应进程</td></tr><tr><td>killall</td><td>通过进程名终止进程</td></tr><tr><td>pkill</td><td>给正在运行的程序进程发送信号</td></tr><tr><td>crontab</td><td>定时任务命令</td></tr><tr><td>ps</td><td>显示进程快照</td></tr><tr><td>pstree</td><td>通过树形结构显示进程</td></tr><tr><td>nice/renice</td><td>调整程序运行时的优先级</td></tr><tr><td>nohup</td><td>可以将以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端</td></tr><tr><td>pgrep</td><td>查找匹配条件的进程</td></tr><tr><td>runlevel</td><td>查看系统当前运行的级别</td></tr><tr><td>init</td><td>切换运行级别</td></tr><tr><td>service</td><td>用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、查看状态（status）等。</td></tr></tbody></table><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>  将比较常用的 Linux 命令整理归纳出来了！有错误的地方还望大家指正，如果还有其他的常用命令，大家可以在评论区留言进行补充。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础知识总结</title>
      <link href="/post/16446/"/>
      <url>/post/16446/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  本文主要是跟大家一起复习一下我之前学习的 java 基础中的知识点的总结。java 的知识点非常的多，它更像是一个成熟稳重的中年大叔。有些我们自以为理解了的知识点，其实只是停留在了他的表面之上，并没有深入了解到其实现原理。</p><p>  纸上得来终觉浅，绝知此事要躬行。java 学习之路很长，我们要不断的学习实践才能深入理解代码的具体实现方式，这样才能造出更加稳固的轮子。</p><h2 id="java-概述"><a href="#java-概述" class="headerlink" title="java 概述"></a>java 概述</h2><p>  Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling 和同事们共同研发，并在 1995 年正式推出。</p><p>Java 分为三个体系：</p><ul><li><p>JavaSE（J2SE）（Java2 Platform Standard Edition，java 平台标准版，完成桌面应用程序的开发，是其它两者的基础；）</p></li><li><p>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java 平台企业版，开发企业环境下的应用程序，主要针对 web 程序开发；)</p></li><li><p>JavaME(J2ME)(Java 2 Platform Micro Edition，java 平台微型版，开发电子消费产品和嵌入式设备，如手机中的程序；)。</p></li></ul><p>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名以取消其中的数字 “2”：J2EE 更名为 Java EE, J2SE 更名为 Java SE，J2ME 更名为 Java ME。</p><h2 id="基础知识总结"><a href="#基础知识总结" class="headerlink" title="基础知识总结"></a>基础知识总结</h2><p>每部分内容会重点写一些常见知识点，方便复习和记忆，但并不是全部内容。</p><ul><li><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3></li></ul><p>  本文以 Windows10 为例进行环境变量配置(Windows11适用此方法)，Windows7 配置环境变量 <a href="https://jingyan.baidu.com/article/9f63fb91d87fb0c8400f0e93.html" title="点击直达">参考这里</a>。</p><p>  首先请确认你的电脑已经安装了 JDK，如果没有安装请点击 <a href="https://www.oracle.com/java/technologies/javase-downloads.html" title="JDK下载">这里下载</a> 你需要的 JDK 版本，安装时建议默认路径就可以，如果有特殊需求可自定义路径。</p><p>  1.在桌面右键此电脑 —&gt;选属性 —&gt;高级系统设置 —&gt;环境变量设置 —&gt;系统变量中点新建如图：<img src="https://media.luckyits.com/obsidian/202307052132639.png" alt="QQ截图20200504163931.png">&lt;/div&gt;</p><p>变量名：<code>JAVA_HOME</code></p><p>变量值：<code>C:\Program Files\Java\jdk1.8.0_202（你JDK的安装路径）</code></p><p>  2.再次点击新建输入如图：</p><div style="text-align:center"> ![QQ截图20200504165155.png](https://media.luckyits.com/obsidian/202307052133331.png)</div><p></p><p>变量名：<code>CLASSPATH</code></p><p>变量值：<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar（需要注意前面有个点）</code></p><p>  3.找到 Path 点编辑，进去之后点新建如图：<img src="https://media.luckyits.com/obsidian/202307052133894.png" alt="QQ截图20200504165632.png">&lt;/div&gt;</p><p>在后面添加 <code>%JAVA_HOME%\bin</code>  <code>%JAVA_HOME%\jre\bin</code>（注意不需要添加; 号，直接另起一行即点击新建添加即可）最后点击确定！</p><ul><li><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3></li></ul><p>  win+R 键 输入 cmd 回车 进入 dos,分别输入 java javac 查看安装是否完成，出现如图即安装成<img src="https://media.luckyits.com/obsidian/202307052133297.png" alt="QQ截图20200504170403.png"></p><center>java</center><p></p><p><img src="https://media.luckyits.com/obsidian/202307052133054.png" alt="QQ截图20200504170428.png"></p><center>javac</center><p></p><ul><li><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3></li></ul><blockquote><p>  继承：一般类只能单继承，内部类实现多继承，接口可以多继承</p><p>  封装：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。访问权限控制 public &gt; protected &gt; 包 &gt; private 内部类也是一种封装</p><p>  多态：编译时多态，体现在向上转型和向下转型，通过引用类型判断调用哪个方法（静态分派）。运行时多态，体现在同名函数通过不同参数实现多种方法（动态分派）。</p></blockquote><ul><li><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3></li></ul><blockquote><p>  Java 语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><p>  级别从低到高为：byte,char,short(这三个平级)—&gt;int—&gt;float—&gt;long—&gt;double</p><p>  自动类型转换：从低级别到高级别，系统自动转的</p><p>  强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量</p></blockquote><ul><li><h3 id="String-及包装类"><a href="#String-及包装类" class="headerlink" title="String 及包装类"></a>String 及包装类</h3></li></ul><blockquote><ol><li>String 类型是 final 类型，在堆中分配空间后内存地址不可变。</li><li>底层是 final 修饰的 char[] 数组，数组的内存地址同样不可变。</li></ol><p>  但实际上可以通过修改 char[n] = ‘a’ 来进行修改，不会改变 String 实例的内存值，不过在 jdk 中，用户无法直接获取 char[]，也没有方法能操作该数组。所以 String 类型的不可变实际上也是理论上的不可变。所以我们在分配 String 对象以后，如果将其 = “abc”，那也只是改变了引用的指向，实际上没有改变原来的对象。</p><ol><li>StringBuffer 和 StringBuilder 底层是可变的 char[] 数组，继承父类 AbstractStringBuilder 的各种成员和方法，实际上的操作都是由父类方法来完成的。</li></ol></blockquote><ul><li><h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3></li></ul><blockquote><ol><li>final 修饰基本数据类型保证不可变</li><li>final 修饰引用保证引用不能指向别的对象，否则会报错。</li><li>final 修饰类，类的实例分配空间后地址不可变，子类不能重写所有父类方法。因此在 cglib 动态代理中，不能为一个类的 final 修饰的函数做代理，因为 cglib 要将被代理的类设置为父类，然后再生成字节码。</li></ol><p>  final 修饰的方法，子类不能重写该方法。</p></blockquote><ul><li><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3></li></ul><blockquote><ol><li>抽象类可以有方法实现。抽象类可以有非 final 成员变量。抽象方法要用 abstract 修饰。抽象类可以有构造方法，但是只能由子类进行实例化。</li><li>接口可以用 extends 加多个接口实现多继承。接口只能有 public final 类型的成员变量。接口只能有抽象方法，不能有方法体，接口不能实例化，但是可以作为引用类型。</li></ol></blockquote><ul><li><h3 id="代码块和加载顺序"><a href="#代码块和加载顺序" class="headerlink" title="代码块和加载顺序"></a>代码块和加载顺序</h3></li></ul><blockquote><p>由 { } 包起来的代码，称为代码块；由 static { } 包起来的代码，称为静态代码块。</p><ol><li>由 static 关键字修饰的，如类变量和静态代码块，将在类创建实例之前被初始化，而且是按顺序从上到下依次被执行。（类变量、静态代码块）属于类本身，不依赖于类的实例。</li><li>没有 static 关键字修饰的（如：实例变量 (非静态变量)、非静态代码块）初始化实际上是会被提取到类的构造器中被执行的，但是会比类构造器中的代码块优先执行。实例变量、非静态代码块的地位是相等的，它们将按顺序被执行。</li><li>静态方法只允许直接访问静态成员，而实例方法中可以访问静态成员和实例成员，原因是类还没有实例化，所以实例成员也没有被创建，静态方法中因此也不能用 this。</li></ol></blockquote><ul><li><h3 id="包、内部类、外部类"><a href="#包、内部类、外部类" class="headerlink" title="包、内部类、外部类"></a>包、内部类、外部类</h3></li></ul><blockquote><ol><li>Java 项目一般从 src 目录开始有 com.<em>.</em>.example.java 这样的目录结构。这就是包结构。所以一般编译后的结构是跟包结构一模一样的，这样的结构保证了 import 时能找到正确的 class 引用包访问权限就是指同包下的类可见。</li></ol><p>  import 一般加上全路径，并且使用.* 时只包含当前目录的所有类文件，不包括子目录。</p><ol><li>外部类只有 public 和 default 两种修饰，要么全局可访问，要么包内可访问。</li><li>内部类可以有全部访问权限，因为它的概念就是一个成员变量，所以访问权限设置与一般的成员变量相同。</li></ol><p>  非静态内部类是外部类的一个成员变量，只跟外部类的实例有关。静态内部类是独立于外部类存在的一个类，与外部类实例无关，可以通过外部类.内部类直接获取 Class 类型。</p></blockquote><ul><li><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3></li></ul><blockquote><ol><li>Execption 可以分为 java 标准定义的异常和程序员自定义异常 2 种</li><li>java 对异常进行了分类，不同类型的异常使用了不同的 java 类，所有异常的根类为 java.lang.Throwable.Throwable 派生了 2 个子类：Error 和 Exception。</li><li>Error 代表了 JVM 本身的错误，不能被程序员通过代码处理，如内存溢出。</li><li>Exception 分为 IoException 和 RuntimeException 。</li></ol><p>  Error 和 RuntimeException 以及他们的子类。Javac 在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常称之为非检查异常，比如下标越界。编译器强制必须 try.catch 处理或 throws 声明继续抛给上层调用方法处理的异常称之为检查异常，比如使用 jdbc 连接数据库的 SQLException。try 块中放可能发生异常的代码。每一个 catch 块用于捕获并处理一个特定的异常，或者这异常类型的子类，顺序为从小到大。finally 无论异常是否发生，异常是否匹配被处理，finally 都会执行。</p></blockquote><ul><li><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3></li></ul><blockquote><ol><li>Java 中的泛型是伪泛型，只在编译期生效，运行期自动进行泛型擦除，将泛型替换为实际上传入的类型。</li></ol><p>  泛型类：ExpClass&lt;<strong>T</strong>&gt;{}</p><ol><li>这样的形式表示，里面的方法和成员变量都可以用 T 来表示类型。泛型接口也是类似的，不过泛型类实现泛型接口时可以选择注入实际类型或者是继续使用泛型。</li><li>泛型方法可以自带泛型比如 void <e> exp();</e></li></ol><p>  泛型可以使用?通配符进行泛化 Object 可以接受任何类型，也可以使用 这种方式进行上下边界的限制。</p></blockquote><ul><li><h3 id="Class-类和-Object-类"><a href="#Class-类和-Object-类" class="headerlink" title="Class 类和 Object 类"></a>Class 类和 Object 类</h3></li></ul><blockquote><ol><li>Java 反射的基础是 Class 类，该类封装所有其他类的类型信息，并且在每个类加载后在堆区生成每个类的一个 Class&lt;类名&gt;实例，用于该类的实例化。</li><li>Java 中可以通过多种方式获取 Class 类型，比如 A.class,new A().getClass() 方法以及 Class.forName(“com.?.?.A”) 方法。</li><li>Object 是所有类的父类，有着自己的一些私有方法，以及被所有类继承的 9 大方法。</li></ol></blockquote><ul><li><h3 id="javac-和-java"><a href="#javac-和-java" class="headerlink" title="javac 和 java"></a>javac 和 java</h3></li></ul><blockquote><ol><li>javac 是编译一个 java 文件的基本命令，通过不同参数可以完成各种配置，比如导入其他类，指定编译路径等。</li><li>java 是执行一个 java 文件的基本命令，通过参数配置可以以不同方式执行一个 java 程序或者是一个 jar 包。</li><li>javap 是一个 class 文件的反编译程序，可以获取 class 文件的反编译结果，甚至是 jvm 执行程序的每一步代码实现。</li></ol></blockquote><ul><li><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3></li></ul><blockquote><ol><li>Java 反射包 reflection 提供对 Class，Method，field，constructor1 等信息的封装类型。</li><li>通过这些 api 可以轻易获得一个类的各种信息并且可以进行实例化，方法调用等。</li></ol><p>  类中的 private 参数可以通过 setaccessible 方法强制获取。</p><ol><li>反射的作用可谓是博大精深，JDK 动态代理生成代理类的字节码后，首先把这个类通过 defineclass 定义成一个类，然后用 class.for(name) 会把该类加载到 jvm，之后我们就可以通过，A.class.GetMethod() 获取其方法，然后通过 invoke 调用其方法，在调用这个方法时，实际上会通过被代理类的引用再去调用原方法。</li></ol></blockquote><ul><li><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3></li></ul><blockquote><ol><li>枚举类继承 Enum 并且每个枚举类的实例都是唯一的。</li><li>枚举类可以用于封装一组常量，取值从这组常量中取，比如一周的七天，一年的十二个月。</li><li>枚举类的底层实现其实是语法糖，每个实例可以被转化成内部类。并且使用静态代码块进行初始化，同时保证内部成员变量不可变。</li></ol></blockquote><ul><li><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3></li></ul><blockquote><ol><li>所有需要网络传输的对象都需要实现序列化接口，建议所有的 javaBean 都实现 Serializable 接口。</li><li>对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient 实例变量都不会被序列化。</li><li>如果想让某个变量不被序列化，使用 transient 修饰。</li><li>readObject 和 writeOject 来实现实例的写入和读取。</li><li>事实上，一些拥有数组变量的类都会把数组设为 transient 修饰，这样的话不会对整个数组进行序列化，而是利用专门的方法将有数据的数组范围进行序列化，以便节省空间。</li><li>反序列化时必须有序列化对象的 class 文件。</li><li>单例类序列化，需要重写 readResolve() 方法；否则会破坏单例原则。</li></ol></blockquote><ul><li><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3></li></ul><blockquote><ol><li>jdk 自带的动态代理可以代理一个已经实现接口的类。</li><li>cglib 代理可以代理一个普通的类。</li><li>动态代理的基本实现原理都是通过字节码框架动态生成字节码，并且在用 defineclass 加载类后，获取代理类的实例。</li><li>一般需要实现一个代理处理器，用来处理被代理类的前置操作和后置操作。在 JDK 动态代理中，这个类叫做 invocationHandler。</li><li>JDK 动态代理首先获取被代理类的方法，并且只获取在接口中声明的方法，生成代理类的字节码后，首先把这个类通过 defineclass 定义成一个类，然后把该类加载到 jvm，之后我们就可以通过，A.class.GetMethod() 获取其方法，然后通过 invoke 调用其方法，在调用这个方法时，实际上会通过被代理类的引用再去调用原方法。</li><li>而对于 cglib 动态代理，一般会把被代理类设为代理类的父类，然后获取被代理类中所有非 final 的方法，通过 asm 字节码框架生成代理类的字节码，这个代理类很神奇，他会保留原来的方法以及代理后的方法，通过方法数组的形式保存。</li></ol><p>  cglib 的动态代理需要实现一个 enhancer 和一个 interceptor，在 interceptor 中配置我们需要的代理内容。如果没有配置 interceptor，那么代理类会调用被代理类自己的方法，如果配置了 interceptor，则会使用代理类修饰过的方法。</p></blockquote><ul><li><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3></li></ul><blockquote><p>Java 线程是一个庞大的话题，以后会考虑专门开一篇进行线程讲解</p><p>  创建多线程 —— 继承 Thread</p><p>  创建多线程 —— 实现 Runnable</p><p>  创建多线程 —— 实现 Callable</p><p>  callable 配合 future 可以实现线程中的数据获取</p><ol><li>Java 中的线程有 7 种状态，new runable running blocked waiting time<em>waiting terminate</em></li></ol><p>  blocked 是线程等待其他线程锁释放。waiting 是 wait 以后线程无限等待其他线程使用 notify 唤醒<br>timewating 是有限时间地等待被唤醒，也可能是 sleep 固定时间。</p><ol><li>多线程操作共享变量，会产生三个问题，可见性、有序性和原子性。</li><li>Thread 的 join 是实例方法，比如 a.join(b),则说明 a 线程要等 b 线程运行完才会运行。</li><li>在 Java 中，每次程序运行至少启动 2 个线程：一个是 main 线程，一个是垃圾收集线程。因为每当使用 java 命令执行一个类的时候，实际上都会启动一个 JVM，每一个 JVM 实际上就是在操作系统中启动了一个进程。</li><li>o.wait 方法会让持有该对象 o 的线程释放锁并且进入阻塞状态，notify 则是持有 o 锁对象的线程通知其他等待锁的线程获取锁。notify 方法并不会释放锁。注意这两个方法都只能在 synchronized 同步方法或同步块里使用。</li><li>synchronized 方法底层使用系统调用的 mutex 锁，开销较大，jvm 会为每个锁对象维护一个等待队列，让等待该对象锁的线程在这个队列中等待。当线程获取不到锁时则让线程阻塞，而其他检查 notify 以后则会通知任意一个线程，所以这个锁时非公平锁。</li><li>Thread.sleep()，Thread.interrupt() 等方法都是类方法，表示当前调用该方法的线程的操作。</li><li>一个线程实例连续 start 两次会抛异常,这是因为线程 start 后会设置标识，如果再次 start 则判断为错误。</li></ol></blockquote><ul><li><h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3></li></ul><blockquote><ol><li>IO 流也是 Java 中比较重要的一块，Java 中主要有字节流，字符流，文件等。其中文件也是通过流的方式打开，读取和写入的。</li><li>IO 流的很多接口都使用了装饰者模式，即将原类型通过传入装饰类构造函数的方式，增强原类型，以此获得像带有缓冲区的字节流，或者将字节流封装成字符流等等，其中需要注意的是编码问题，后者打印出来的结果可能是乱码哦。</li><li>IO 流与网络编程息息相关，一个 socket 接入后，我们可以获取它的输入流和输出流，以获取 TCP 数据包的内容，并且可以往数据报里写入内容，因为 TCP 协议也是按照流的方式进行传输的，实际上 TCP 会将这些数据进行分包处理，并且通过差错检验，超时重传，滑动窗口协议等方式，保证了 TCP 数据包的高效和可靠传输。</li></ol></blockquote><ul><li><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3></li></ul><blockquote><p>承接 IO 流的内容</p><ol><li>IO 流与网络编程息息相关，一个 socket 接入后，我们可以获取它的输入流和输出流，以获取 TCP 数据包的内容，并且可以往数据报里写入内容，因为 TCP 协议也是按照流的方式进行传输的，实际上 TCP 会将这些数据进行分包处理，并且通过差错检验，超时重传，滑动窗口协议等方式，保证了 TCP 数据包的高效和可靠传输。</li><li>除了使用 socket 来获取 TCP 数据包外，还可以使用 UDP 的 DatagramPacket 来封装 UDP 数据包，因为 UDP 数据包的大小是确定的，所以不是使用流方式处理，而是需要事先定义他的长度，源端口和目标端口等信息。</li><li>为了方便网络编程，Java 提供了一系列类型来支持网络编程的 api，比如 URL 类，InetAddress 类等。</li></ol></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  简单总结了一下 java 中的一些基础知识点，有错误的地方还恳请各位进行指正！Java 的知识点其实非常多，并且有些知识点比较难以理解，有时候我们自以为理解了某些内容，其实可能只是停留在表面上，没有理解其底层实现原理。学无止境！我们工作中也应该学会总结！</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 开发 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu修改镜像源</title>
      <link href="/post/63542/"/>
      <url>/post/63542/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Ubuntu 使用的下载源服务器在国外，因此在使用的的时候，特别的慢，因此换国内的 Ubuntu 镜像源，便成了解决速度慢的优选方案。国内的知名镜像源有很多，比如阿里云、华为云、清华大学镜像源……等国内知名镜像源。</p><h2 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> upgrade</code></pre><h2 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h2><p>Ubuntu 中软件更新的源服务器地址存储在/etc/apt/soures.list 中</p><ul><li><strong>备份配置文件</strong></li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">cp</span> <span class="token parameter variable">-a</span> /etc/apt/sources.list /etc/apt/sources.list.bak</code></pre><ul><li><strong>修改 sources.list 文件</strong></li></ul><p>将 <a href="http://archive.ubuntu.com">http://archive.ubuntu.com</a> 和 <a href="http://security.ubuntu.com">http://security.ubuntu.com</a> 替换成 <a href="http://mirrors.aliyun.com">http://mirrors.aliyun.com</a> 可以参考如下命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s@http://.*archive.ubuntu.com@http://mirrors.aliyun.com@g"</span> /etc/apt/sources.list<span class="token function">sudo</span> <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s@http://.*security.ubuntu.com@http://mirrors.aliyun.com@g"</span> /etc/apt/sources.list</code></pre><ul><li><strong>更新索引</strong></li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> upgrade <span class="token parameter variable">-y</span></code></pre><h2 id="其他镜像源"><a href="#其他镜像源" class="headerlink" title="其他镜像源"></a>其他镜像源</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 华为云镜像</span><span class="token function">sudo</span> <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g"</span> /etc/apt/sources.list<span class="token function">sudo</span> <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g"</span> /etc/apt/sources.list<span class="token comment"># 清华源</span><span class="token function">sudo</span> <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s@http://.*archive.ubuntu.com@http://mirrors.tuna.tsinghua.edu.cn@g"</span> /etc/apt/sources.list<span class="token function">sudo</span> <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s@http://.*security.ubuntu.com@http://mirrors.tuna.tsinghua.edu.cn@g"</span> /etc/apt/sources.list</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git乱码问题解决</title>
      <link href="/post/44647/"/>
      <url>/post/44647/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="📅-时间：2020-11-01"><a href="#📅-时间：2020-11-01" class="headerlink" title="📅 时间：2020-11-01"></a>📅 时间：2020-11-01</h3><h3 id="☀️天气：-√-☀️-☁️-🌧️-❄️"><a href="#☀️天气：-√-☀️-☁️-🌧️-❄️" class="headerlink" title="☀️天气：- [√] ☀️ - [ ] ☁️ - [ ] 🌧️ - [ ] ❄️"></a>☀️天气：- [√] ☀️ - [ ] ☁️ - [ ] 🌧️ - [ ] ❄️</h3><h2 id="☞今日复盘小结"><a href="#☞今日复盘小结" class="headerlink" title="☞今日复盘小结"></a>☞今日复盘小结</h2><p>git 升级之后在 Windows Terminal 中使用 ls 命令中文出现乱码，在 Git 的安装目录下的 etc 目录下 <code>bash.bashrc</code> 文件，在最后一行添加：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span><span class="token string">"zh_CN.UTF-8"</span> <span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LC_ALL</span></span><span class="token operator">=</span><span class="token string">"zh_CN.UTF-8"</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> Windows Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语听力学习笔记</title>
      <link href="/post/34288/"/>
      <url>/post/34288/</url>
      
        <content type="html"><![CDATA[<h1 id="外语精听练习-1018"><a href="#外语精听练习-1018" class="headerlink" title="外语精听练习 1018"></a>外语精听练习 1018</h1><p><strong>City Lights Chapter 5 James’ House 2020-10-18</strong></p><h2 id="听力练习记录"><a href="#听力练习记录" class="headerlink" title="听力练习记录"></a>听力练习记录</h2><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">听写结果</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><em>将音频素材放入笔记内，逐词逐句把听到的内容记录下来。听写完毕后，根据原文边听边对照，进行纠错。</em></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">总结失误原因</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><em>纠错完成后，逐一进行原因总结：生词？语速？口音？<strong>1、</strong>2、**3、</em></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">生词</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">英文</td><td style="text-align:left">释义</td><td style="text-align:left">句中搭配</td></tr><tr><td style="text-align:left">humble</td><td style="text-align:left">adj.简陋的</td><td style="text-align:left">Welcome to my humble home.</td></tr><tr><td style="text-align:left">choice</td><td style="text-align:left">n.选择</td><td style="text-align:left">Yeah，it was my father’s choice</td></tr><tr><td style="text-align:left">for no reason</td><td style="text-align:left">毫无道理</td><td style="text-align:left">sure，you did…This room is so big for no reason. Are you sure your fatehr</td></tr><tr><td style="text-align:left">court</td><td style="text-align:left">n.球场</td><td style="text-align:left">didn’t want this to be a basketball courk</td></tr><tr><td style="text-align:left">beggar</td><td style="text-align:left">n.乞丐</td><td style="text-align:left">A beggar?What’s going on here Master James?</td></tr><tr><td style="text-align:left">stealing</td><td style="text-align:left">v.偷</td><td style="text-align:left">He’s probably stealing things right now.</td></tr><tr><td style="text-align:left">actually</td><td style="text-align:left">adv.真正地</td><td style="text-align:left">Oh，Charlie‘s not like that.He’s better than you think.You’ll understand when you actually get to know him better.</td></tr><tr><td style="text-align:left">scared</td><td style="text-align:left">adj.害怕的</td><td style="text-align:left">Oh… ohh! Now i’m a little bit scared</td></tr><tr><td style="text-align:left">dumped</td><td style="text-align:left">v.抛弃</td><td style="text-align:left">It doesn’t mean you have to be this low just because she dumped you.</td></tr><tr><td style="text-align:left">长难句解析</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><em>把错误较多的句子、新学到的单词或句型都标注出来，以便日后复习。</em></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">原句</td><td style="text-align:left">Speaking of the devil</td></tr><tr><td style="text-align:left">分解</td><td style="text-align:left">speak of the devil 是固定短语</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">释义</td><td style="text-align:left">说曹操，曹操到</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">原句</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">分解</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">释义</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">原句</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">分解</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">释义</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">精彩语句摘录</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><em>把精彩句子摘录下来，将句型和表达化为己用。</em></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">原句</td><td style="text-align:left">Hey,it was a mutual dumping,all right.We agreed that we are not the right one for each other.</td></tr><tr><td style="text-align:left">分解</td><td style="text-align:left">each other 为固定搭配，意为“互相”</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">释义</td><td style="text-align:left">嘿，我们是互相抛弃的，好吗。我们都赞同我们不合适。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">原句</td><td style="text-align:left">So that’s where your money came from</td></tr><tr><td style="text-align:left">分解</td><td style="text-align:left">come from 为常用搭配，意为“来自”</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">释义</td><td style="text-align:left">所以你的钱来自那里。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">原句</td><td style="text-align:left">You’ll understand when you actually get to know him better.</td></tr><tr><td style="text-align:left">分解</td><td style="text-align:left">get to know 为常用搭配，表示“逐渐熟悉”</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">释义</td><td style="text-align:left">等你真正逐渐熟悉他一点你就会明白。</td></tr></tbody></table></div><h2 id="听力原文"><a href="#听力原文" class="headerlink" title="听力原文"></a>听力原文</h2><p><img src="https://img.luckyits.com/2024/05/20/664b03a55e67d.jpg" alt="QQ图片20201018151401.jpg&quot;; filename\*=utf-8''QQ%E5%9B%BE%E7%89%8720201018151401.jpg">  </p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 英语 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 听力学习 </tag>
            
            <tag> 学习记录 </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
